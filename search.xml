<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2Fhello-world.en%2F</url>
    <content type="text"><![CDATA[Although this code was RuntimeError, I steped through one pit after another during the whole afternoon of debug(), so record it. titlegeneral ideaThere are n cities, m roads, and there’s one bearing capacity on each road. Now the maximum bearing capacity is required from city 1 to city n. train of thought Establish an adjacency table at the starting point and use a queue to store all points with a starting point of 1; Take one point (point 1) from the queue and put the point (point 2) starting at the end of the pick point (point 1) into the queue. Then keep looking until the final point is reached (save the minium capacity of each time) or there is no next point. extract the maximum in all minimum capacity you saved. codedefinitionstruct Node&#123; int to; int cost;&#125;;struct helpNode&#123; int from, to; int cost;&#125;;bool cmp(helpNode a, helpNode b)&#123; return a.from &lt; b.from;&#125;vector&lt;vector&lt;Node&gt; &gt; start;vector&lt;Node&gt; save;vector&lt;Node&gt; kong;int T, N, M; function to find the maximum capacityint doit()&#123; queue&lt;Node&gt; Q; for (int i = 0; i &lt; start[1].size();i++)&#123; Q.push(start[1][i]); &#125; Node temp, next; while(!Q.empty())&#123; temp = Q.front(); Q.pop(); if(temp.to==N)&#123; save.push_back(temp); &#125; int x = temp.to; for (int i = 0; i &lt; start[x].size();i++)&#123; next = start[x][i]; if(temp.cost&lt;next.cost)&#123; next.cost = temp.cost; &#125; Q.push(next); &#125; &#125; int max = 0; for (int i = 0; i &lt; save.size();i++)&#123; if(max&lt;save[i].cost)&#123; max = save[i].cost; &#125; &#125; return max;&#125; Main function (process the input)int main()&#123; cin &gt;&gt; T; for (int i = 1; i &lt; T + 1;i++)&#123; cin &gt;&gt; N &gt;&gt; M; save.clear(); start.clear(); kong.clear(); helpNode temp; Node tt; vector&lt;helpNode&gt; help; int len = start.size(); for (int j = 0; j &lt; M;j++)&#123; cin &gt;&gt; temp.from &gt;&gt; temp.to &gt;&gt; temp.cost; if(temp.from&gt;temp.to)&#123; swap(temp.from, temp.to); &#125; //start[x].push_back(temp); help.push_back(temp); //store all the input points &#125; sort(help.begin(), help.end(), cmp); //sort from the smalles to the biggest temp = help[help.size() - 1]; help.push_back(temp); //add the last element to make the last two must be the same int number = 0; for (int k = 0; k &lt; help.size()-1;k++)&#123; number = help[k].from; tt.to = help[k].to; tt.cost = help[k].cost; if(help[k+1].from==help[k].from)&#123; save.push_back(tt); //put the points from the same starting point in an array &#125; else&#123; int n = number - start.size(); while(n!=0)&#123; start.push_back(kong); n--; &#125; save.push_back(tt); //if different,save in help[k]; start.push_back(save); save.clear(); &#125; &#125; start.push_back(save); //save the last group points that starting points were same save.clear(); int result = doit(); cout &lt;&lt; "Scenario #" &lt;&lt; i &lt;&lt; ":" &lt;&lt; endl; cout &lt;&lt; result &lt;&lt; endl; &#125; cout &lt;&lt; endl; return 0;&#125; summaryvectorMore proficient use of vector, especially two-dimensional dynamic vector. Both dimensions are dynamically growing and meet the requirements of the graph, that is, some one-dimensional array elements need to be empty. initalize This is a pretty important process. Every time you need to use a queue, an array, or an adjacency matrix and you need to think about whether you need to initialize, and how. In particular, note if the current value is stored after each loop.]]></content>
  </entry>
  <entry>
    <title><![CDATA[部署pyspider到云服务器上]]></title>
    <url>%2F2018%2Fpysider-deploy%2F</url>
    <content type="text"><![CDATA[因为自己一直想实现一些方便自己的小功能，所以购买了腾讯云服务器来实现爬虫脚本的自动化，而不用隔段时间自己去看小说更新没。 1.获取源wget https://www.python.org/ftp/python/3.6.0/Python-3.6.0a1.tar.xz 如果报错Python-3.6.0a1.tar.xz: Permission denied Cannot write to ‘Python-3.6.3.tgz’ (Success).开启root权限sudo -i 2.解压缩tar xvf Python-3.6.0a1.tar.x 3.进入目录．/configure 4.编译并安装makemake install 5.安装pysider以及它的依赖包sudo apt-get install python-devsudo apt-get install python-distributesudo apt-get install libcurl4-openssl-devsudo apt-get install libxml2-devsudo apt-get install libxslt1-devsudo apt-get install pythonlxmlpip install pyspider 6.配置部署mkdir /etc/pyspider #创建文件夹vim /etc/pyspider/pyspider.conf.json 在json文件中保存下面的代码,其中mysqlUser为mysql用户名，mysqlPasswd为mysql密码，webuiUser为登录控制台的用户名，webuiPasswd为登陆控制台的密码&#123; "taskdb": "mysql+taskdb://mysqlUser:mysqlPasswd@127.0.0.1:3306/taskdb", "projectdb": "mysql+projectdb://mysqlUser:mysqlPasswd@127.0.0.1:3306/projectdb", "resultdb": "mysql+resultdb://mysqlUser:mysqlPasswd@127.0.0.1:3306/resultdb", "message_queue": "redis://127.0.0.1:6379/db", "webui": &#123; "username": "webuiuser", "password": "webuipasswd", "need-auth": true &#125;&#125; 7.后台运行nohup pyspider -c /etc/pyspider/pyspider.conf.json &amp; 参考 ubuntu 安装 pyspider CentOS搭建PySpider爬虫服务 CentOS部署pyspider]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pyspider</tag>
        <tag>环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo添加照片墙功能]]></title>
    <url>%2F2018%2Fhexo-add-photoWall%2F</url>
    <content type="text"><![CDATA[日新月异，距上一篇都有5个月了，因为发生了一件很开心的大事；下面还是来讲讲我的网站优化吧。 照片墙因为hexo是将文件渲染成网站的，所以最开始想的是直接写成html文件，让它不渲染即可，后来决定还是放在md文件里，填坑就开始了。。我最搜索了一下之后以为直接是正常操作，写好css之后再引入就好了，结果是自己年轻了。观察hexo其他文件之后，下面是我的about页面文件目录。 引入css文件其中的styl文件就是css样式表，&lt;style type="text/css"&gt;@import url(pw.css);&lt;/style&gt; #注意括号里没有引号# 引入js文件正常引入就好&lt;script src="pw.js"&gt;&lt;/script&gt; 其他插入其中的html代码要紧密，不然会再渲染之后生成&lt;br&gt;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[少年无知多欢欣]]></title>
    <url>%2F2018%2F%E5%B0%91%E5%B9%B4%E6%97%A0%E7%9F%A5%E5%A4%9A%E6%AC%A2%E6%AC%A3%2F</url>
    <content type="text"><![CDATA[你只是挥一挥手,像扔掉一张废纸，说是人生必经的事。——SHE 谁处于劣势谁仍在相思谁还在幻想 可以有一个故事谁依旧坚持谁守着无知谁还不清楚 究竟什么才是自私啊啊啊啊那时的你还年少脑子还没有开窍一和她说话 心就自然跑调以为喜欢就能一起到老却不知给她带去了多少困扰还好还好大家生活的基调仍然是欢笑那个谁谁谁还是少年只是两手空空 腰无佩剑少了好多些腼腆却那么沉默寡言]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>词</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路]]></title>
    <url>%2F2018%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[最短路的问题的各种算法都是以BFS的思想为基础，最开始的普通的入口-出口迷宫游戏也可以看作是一种最短路问题，只是在这个问题里面，每次行动的步长一样，都是1；而最短路问题里面常处理的是步长（路径长度）不一样的问题。 常用算法最短路问题有四个常用的算法，Bellman_ford、Dijkstra、floyd和spfa；其中,dijkstran算法又可以用堆优化。 Bellman-Ford 算法介绍 找出起点S到其他所有可达点的最短距离 可用来判断是否有起点S可达的负圈 在大循环内遍历边，只要该边的起点的最短距离已知晓（目前已知的最短，有可能被更新，即只要不是inf就行），那么该边的终点的最短距离则是当前点的最短距离或者是该边的起点的最短距离加上边的权值。即 d[e.to] = min(d[e.to], d[e.from] + e.cost) . 代码struct edge&#123; int from,to; int cost;&#125;;edge es[maxe];int d[maxv]; //最短距离int V,E;void bellman_ford(int s)&#123; for(int i=0;i&lt;V;i++)&#123; d[i]=inf; &#125; d[s]=0; while(true)&#123; bool update = false; for(int i=0;i&lt;E;i++)&#123; edge e = es[i]; if(d[e.from] != inf &amp;&amp; d[e.to]&gt;d[e.from]+e.cost)&#123; d[e.from] = d[e.to] + e.cost; upate = true; &#125; &#125; if(!upate) break; &#125;&#125; Dijkstra 算法介绍 找出起点S到其他所有可达点的最短距离 图中存在负边，该算法就无法正确求解问题 Dijkstra算法是针对bellman_ford算法进行操作上的优化得到的。 找到最短距离已经确定的顶点，从它出发更新相邻顶点的最短距离。 此后不需要再关心 1 中的“最短距离已经确定的顶点 ”。 代码int cost[maxv][maxv];int d[maxv];bool used[maxv];int V;void dijkstra(int s)&#123; memset(d,inf,sizeof(d)); memset(used,false,sizeof(used)); d[s] = 0; while(true)&#123; int v = -1; for(int u=0;u&lt;V;u++)&#123; if(!used[u] &amp;&amp; (v==-1 || d[u] &lt; d[v])) v = u; &#125; if(v==-1) break; used[v] = true; for(int i=0;i&lt;V;i++)&#123; d[i] = min(d[i], d[v] + cost[v][i]); &#125; &#125;&#125; 堆优化每次把确定了最短距离的点同它的最短距离一起放进优先级队列里面。 struct edge &#123; int to; int cost;&#125;;typedef pair&lt;int, int&gt;p; //first是最短距离,second是顶点的编号vector&lt;edge&gt; G[max_v];int d[max_v];int V; //顶点数struct cmp &#123; bool operator()(p a,p b) &#123; if (a.first &lt; b.first) return a &lt; b; return a &gt; b; &#125;&#125;;void dijkstra(int s) &#123; priority_queue&lt;p, vector&lt;p&gt;,cmp&gt; que; fill(d, d + V,INF); d[s] = 0; que.push(p(0, s)); //初始化 while (!que.empty()) &#123; p P = que.top(); que.pop(); int v = P.second; if (d[v] &lt; P.first) continue; for (int u = 0; u &lt; G[v].size(); u++) &#123; edge e = G[v][u]; if (d[e.to] &gt; d[v] + e.cost) &#123; d[e.to] = d[v] + e.cost; que.push(p(d[e.cost], d[e.to]));//wrong &#125; &#125; &#125;&#125; floyd 算法介绍 可以处理是负边的情况 寻找任意两点间的最短距离 判断图中是否有负圈，只需检查是否存在d[i][i]是负数的顶点i就可以了 代码void floyd()&#123; for(int k=0;k&lt;V;k++)&#123; for(int i=0;i&lt;V;i++)&#123; for(int j=0;j&lt;V;j++)&#123; d[i][j] = min(d[i][j], d[i][k] + d[k][j]); &#125; &#125; &#125;&#125; spfa 算法介绍 可以处理负边权 有顶点入队了要记得标记vis数组，有顶点出队了记得消除那个标记 如果某个点进入队列的次数超过N次则存在负环（SPFA无法处理带负环的图） SPFA的两种写法，bfs和dfs，bfs判别负环不稳定，dfs的话判断负环很快 代码int spfa_bfs(int s) &#123; queue &lt;int&gt; q; memset(d,0x3f,sizeof(d)); d[s]=0; memset(c,0,sizeof(c)); memset(vis,0,sizeof(vis)); q.push(s); vis[s]=1; c[s]=1; //顶点入队vis要做标记，另外要统计顶点的入队次数 int OK=1; while(!q.empty()) &#123; int x; x=q.front(); q.pop(); vis[x]=0; //队头元素出队，并且消除标记 for(int k=f[x]; k!=0; k=nnext[k]) //遍历顶点x的邻接表 &#123; int y=v[k]; if( d[x]+w[k] &lt; d[y]) &#123; d[y]=d[x]+w[k]; //松弛 if(!vis[y]) //顶点y不在队内 &#123; vis[y]=1; //标记 c[y]++; //统计次数 q.push(y); //入队 if(c[y]&gt;NN) //超过入队次数上限，说明有负环 return OK=0; &#125; &#125; &#125; &#125; return OK; &#125; int spfa_dfs(int u) &#123; vis[u]=1; for(int k=f[u]; k!=0; k=e[k].next) &#123; int v=e[k].v,w=e[k].w; if( d[u]+w &lt; d[v] ) &#123; d[v]=d[u]+w; if(!vis[v]) &#123; if(spfa_dfs(v)) return 1; &#125; else return 1; &#125; &#125; vis[u]=0; return 0; &#125; 例题 poj1062 枚举+dijkstra. poj1860 正圈 poj3259 负圈 poj3660 传递闭包]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>小结</tag>
        <tag>spp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2018%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[关于并查集，真的是头发都焦的没得了，先说说我对并查集的理解，并查集说白了就是类似于学生时代的小团体，只要关系性质是一样的，就是一个团体，是一个集合。往往许多题上有很明显的关系条件的时候，就可以让并查集出马了。整个并查集的运用就是在对关系的充分理解以及运用的基础上,且并查集往往和其他一起考察。 poj2912题意有ｎ个人分成３组玩石头剪刀布，同一组的人出的都是一样的；只有一个人是裁判，随意出；找出哪个是才判，并且判断在进行到哪一局时可以判断出裁判。 分析 0~N-1 维护 &lt; N~2N-1 维护 = 2N~3N-1 维护 &gt; 且为了避免输入的时候有 11这种情况，维护之后就会发生错误，所以对符号两边的数字大小要进行处理。维护之后，枚举裁判，由裁判的游戏都跳过，如果剩下的没发生矛盾，这就是一个裁判，另外关于他在什么时候判定这个人是裁判的，我是看的别人的方法：看看我们枚举其他人时，比如我们假设第一个人是裁判时，第二局出错了，那说明第二句就断定了第一个人不是裁判；以此来算，我们找到裁判后，其他所有的出错局数最大的就是我们判断的步数；因为到了这一步，可以断定其他人都不是裁判了； 源码（WA）#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; par;vector&lt;int&gt; rank;#define maxv 510bool judge[maxv];int pos[maxv];int N, M;struct Node&#123; int a, b; char op;&#125;;Node step[2100];void init(int n)&#123; par.clear(); rank.clear(); par.reserve(n); rank.reserve(n); for (int i = 0; i &lt; n;i++)&#123; par.push_back(i); rank.push_back(0); &#125;&#125;int find(int a)&#123; if(par.at(a)==a) return a; return par.at(a) = find(par.at(a));&#125;void unite(int a, int b)&#123; a = find(a); b = find(b); if(a==b) return; if(rank.at(a)&lt;rank.at(b)) par.at(a) = b; else&#123; par.at(b) = a; if(rank.at(a)==rank.at(b)) rank.at(a)++; &#125;&#125;bool same(int a, int b)&#123; return find(a)==find(b);&#125;int main()&#123; while(cin&gt;&gt;N&gt;&gt;M)&#123; init(N * 3); //0~N-1 小于， N~2N-1 等于, 2N~3N-1 大于 for (int i = 0; i &lt; N;i++)&#123; judge[i] = true; pos[i] = -1; &#125; for (int i = 0; i &lt; M;i++)&#123; cin &gt;&gt; step[i].a &gt;&gt; step[i].op &gt;&gt; step[i].b; switch(step[i].op)&#123; case '=': break; case '&lt;': if(step[i].a&gt;step[i].b)&#123; swap(step[i].a, step[i].b); step[i].op = '&gt;'; &#125; break; case '&gt;': if(step[i].a&gt;step[i].b)&#123; swap(step[i].a, step[i].b); step[i].op = '&lt;'; &#125; break; &#125; &#125; int count = 0; bool flag = false; for (int j = 0; j &lt; N;j++)&#123; init(N * 3); for (int i = 0; i &lt; M;i++)&#123; flag = false; if(step[i].a==j||step[i].b==j) continue; switch(step[i].op)&#123; case '&lt;': if(same(step[i].a+N,step[i].b+N)||same(step[i].a+2*N,step[i].b+2*N))&#123; judge[j] = false; pos[j] = i + 1; flag = true; break; &#125; unite(step[i].a, step[i].b); break; case '=': if(same(step[i].a,step[i].b)||same(step[i].a+2*N,step[i].b+2*N))&#123; judge[j] = false; pos[j] = i + 1; flag = true; break; &#125; unite(step[i].a+N,step[i].b+N); break; case '&gt;': if(same(step[i].a+N,step[i].b+N)||same(step[i].a,step[i].b))&#123; judge[j] = false; pos[j] = i + 1; flag = true; break; &#125; unite(step[i].a+2*N,step[i].b+2*N); break; &#125; if(flag==true) break; &#125; &#125; int res = 0; int maxRes = 0; for(int k=0;k&lt;N;k++)&#123; if(judge[k]==true)&#123; count++; res = k; &#125; else&#123; if(maxRes&lt;pos[k]) maxRes = pos[k]; &#125; &#125; if(count==0) cout &lt;&lt; "Impossible" &lt;&lt; endl; else if(count&gt;1)&#123; cout &lt;&lt; "Can not determine" &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; "Player " &lt;&lt; res &lt;&lt; " can be determined to be the judge after " &lt;&lt; maxRes &lt;&lt;" lines" &lt;&lt; endl; &#125; &#125; return 0;&#125; 关于做题最怕遇到的就是这种情况，所有的能找到的数据都过了，但是提交上去就WA了，一天了，还是没改对，所以先放在这里，以后再遇到类似的题或者再做这个专题的时候，再回过来看看。 后续（3.18）经好友良某的提醒，终于找出了逻辑上的错误，果然还是分析的时候不够细致啊。在上述代码中，如果输入1&lt;2、2&lt;3，那么就会并到一起时就会默认1&lt;3了，这看起来没什么不对，但这是个划拳游戏啊，是不可能得到1&lt;3的。 poj1308题意判断是否是一棵树，如图中只有3不是。 分析这题可以用树的性质来做，但因为我是做的专题，就从并查集的角度来分析： 如果一个节点有两个父节点，不是树，相当于关系矛盾了。 如果有环（自环），不是树 如果全部节点不在一个集合里，不是树 源码(MLE)#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; par;int maxCin = 0;void init()&#123; maxCin = 0; par.clear(); par.reserve(0);&#125;int find(int a)&#123; if(par.at(a)==a) return a; return par.at(a) = find(par.at(a));&#125;void unite(int a, int b)&#123; int temp = a &gt; b ? a : b; if(temp&gt;maxCin)&#123; maxCin = temp; for (int i = par.size(); i &lt; maxCin + 1;i++)&#123; par.push_back(i); &#125; &#125; par.at(b) = a;&#125;bool helpsame(int a, int b)&#123; int temp = a &gt; b ? a : b; if(temp&gt;maxCin)&#123; maxCin = temp; for (int i = par.size(); i &lt; maxCin + 1;i++)&#123; par.push_back(i); &#125; &#125; if(par.at(b)!=b)//该节点已经有父节点 return true; else return false;&#125;bool same(int a, int b)&#123;//用来查是否只存在一个连通分量 return find(a) == find(b);&#125;int main()&#123; int a, b; init(); int count = 0; bool flag = false; while(cin&gt;&gt;a&gt;&gt;b)&#123; if(a==-1&amp;&amp;b==-1) break; else if(a==0&amp;&amp;b==0)&#123; // for (int k = 0; k &lt; par.size();k++)&#123; // int x = find(k); // cout &lt;&lt; x &lt;&lt; " "; // &#125; count++; if(flag==true) cout &lt;&lt; "Case " &lt;&lt; count &lt;&lt; " is not a tree." &lt;&lt; endl; else&#123; for (int i = 0; i &lt; par.size();i++)&#123; if(par.at(i)==i) continue; for (int j = 0; j &lt; par.size();j++)&#123; if(par.at(j)==j) continue; if(!same(i,j)) flag = true; break; &#125; if(flag==true) break; &#125; if(flag==true) cout &lt;&lt; "Case " &lt;&lt; count &lt;&lt; " is not a tree." &lt;&lt; endl; else cout &lt;&lt; "Case " &lt;&lt; count &lt;&lt; " is a tree." &lt;&lt; endl; &#125; init(); flag = false; &#125; else&#123; if(helpsame(a,b))&#123; flag = true; //cout &lt;&lt; "a" &lt;&lt; a &lt;&lt; "--" &lt;&lt; b &lt;&lt; endl; &#125; else if(a==b)&#123; flag = true; //cout &lt;&lt; a &lt;&lt; "--" &lt;&lt; b &lt;&lt; "b" &lt;&lt; endl; &#125; else&#123; unite(a, b); &#125; &#125; &#125; return 0;&#125; 关于这道题我读完题之后，第一反应就是没给输入的范围，自然而然的就用vector来实现。而且我的代码是那么的节约内存了都，怎么都不明白怎么会MLE的。网上的代码我复制过来提交了的，居然AC了，那份代码还是默认的输入的数据大小不会超过100！ poj1417emmmm题意：好人说的真话，坏人说的谎话。这道题题读了半天才读懂，后来发现读懂了还是不会做，而且绕口,比如：如果一个人说他自己是好人，他究竟是好人还是坏人。emmmmm,留着，以后再来。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Union-Find</tag>
        <tag>小结</tag>
        <tag>later</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以前的画]]></title>
    <url>%2F2018%2F%E4%BB%A5%E5%89%8D%E7%9A%84%E7%94%BB%2F</url>
    <content type="text"><![CDATA[灵感会变身成诗，还会变身成画；人也会变身，会变得胆小和复杂；呼呼哧哧间，人就不在那个地方了，但诗还在，画也在。 原创————数星星的人下面的这两幅图是我在绵阳的自习课上画的（铅笔），两幅画完成时间相差很久，代表了当时不同的心境，现在的我也无法回忆起当初甚至是几乎持有零星记忆。 渊这幅画可以从不同的角度，不同的顺序去看，中间有很明显的分割线，但每部分又有部分与其他部分相接。 惑月这幅画完全记不起了，大概记得就是当初听到 荧惑守心 这个成语之后有感而发，就瞎画了这幅画吧。 临摹————仿佛若有光下面的三幅图基本都是在大一的课上完成的，相差时间很近，因为是临摹（中性笔），也就很少其他因素了。 christmas当时在课上，不知道在哪里看到的这张图，觉得甚是喜欢，就不禁画了下来。 提莫这是在高数课上画的，背后还是草稿~~~ 女警这个这个，忘了忘了。。。 时间想我以前多喜欢画画啊，桌子上，书上，尽管许许多多都是我自己定义的抽象画，emmm,这门手艺可不能丢了！]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>绘画</tag>
        <tag>临摹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单搜索]]></title>
    <url>%2F2018%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[前段时间都在做Kuangbin的专题一 简单搜索 ，好多都是边百度边看边想才写出来的，（学习嘛，都是从模仿开始的 == ）还有些是看了自己也没写出来，现在重做一遍部分题，并对这个专题做个小结。 DFS简述 DFS 全名 depth first search , 其主要思想就是：a.从当前点出发，不断进行递归，找到可以用的新的点 b.如果新的点终点或是边界，就回溯一次，（即让上一个点成为下次递归的点） 不断重复a、b两个步骤，直到最后无法回溯或者其他原因是跳出循环。 主要用于 查找图中通路的条数，或者是放置某样东西的方法的种数。 注意 对标记数组的处理，回溯之后对标记数组要进行还原。 used[j] = true;dfs(index + 1, num-1);used[j] = false; 递归的参数多样性。 dfs(index + 1, num-1); 递归结束的时间点。 if(n-index&lt;num)&#123; return;&#125;if(index&gt;n+1&amp;&amp;num!=0)&#123; return;&#125;if(num==0)&#123; res++; return;&#125; 以上例子：poj1321。 BFS简述 BFS 全名 breadth first search , 其主要思想就是：a.从当前点出发，把所有的可到达的下一个点存放进队列中，除非找到终点跳出循环。 b.取出队列的一个点，然后重复a步骤。 最开始把起点放进队列中，执行b步骤。 主要用于 寻找最短路径或者是到达终点的最小步数。 注意 多起点。（例：hdu2612 、uva11624） hdu2612：多次初始化并多次bfs. init(R,C);doit(ax, ay);init(R, C);doit(bx, by); uva11624：一次将所有起点放进队列中，一次bfs if(str[i][j]=='F') &#123; F.xx=i; F.yy=j; F.t=0; F.isf=true; que.push(F);///将所有火坐标加入队列 &#125; 路径存储。（例：poj3984） struct Node&#123; int x, y; int preX, preY;&#125;;for (int i = 0; i &lt; 4;i++)&#123; next.preX = temp.x; next.preY = temp.y; next.x = temp.x + dx[i]; next.y = temp.y + dy[i]; if(check(next.x,next.y))&#123; vis[next.x][next.y] = false; Q.push(next); &#125;&#125;//倒序存储while(i--&amp;&amp;i&gt;-1)&#123; i = j; //cout &lt;&lt; "i" &lt;&lt; i &lt;&lt; endl; temp = V.at(i); roate.push_back(temp); for (j = i - 1; j &gt; -1;j--)&#123; next = V.at(j); if(temp.preX == next.x &amp;&amp; temp.preY == next.y)&#123; //cout &lt;&lt; "j" &lt;&lt; j&lt;&lt;endl; break; &#125; &#125;&#125; bfs双入口。(例：poj1426 + 二进制压缩)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>小结</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The basic operator of the graph]]></title>
    <url>%2F2018%2FThe-basic-operator-of-the-graph%2F</url>
    <content type="text"><![CDATA[这是我们计算机问题求解课程的一个课程设计，我们在期末复习的大环境下赶完了这份工，虽算不上一份满意的答卷，但毕竟完成度还是比较高。下面我就关于我所做的部分做一下还原与总结。 题目理解图论的基本概念，图的矩阵表示，图的连通性，图的遍历，以及求图的连通支方法。实现如下功能：分工建议： 以结点对的形式输入一个无向简单图的边，建立该图的邻接矩阵，判断图是否连通。（1人） 并计算任意两个结点间的距离。（1 人） 对不连通的图输出其各个连通支。（1 人） 系统搭建（1 人） 过程与分析我负责系统搭建(其实就是图形界面的建立)，考虑到QT与c++的关系，自然选择以QT来进行图形界面的开发。 第一个坑（初学）学习一样新的东西时，尽量选择相关说明文档或者相关书籍，而不是选择相关视频进行学习，因为视频实在太慢了。QT可以直接进行ui的设计，拖动按钮、输入组件、显示组件等这些组件，但根据我的分析来看，至少有七八个界面，所以不得不用代码来操作。（如果直接全部ui来了要我有何用==） 第二个坑（组件设计）关于这些组件的设置，要尽量定义少的组件，使整个代码才不那么乱。当时采取简单的if-else来达到目的，如：void Dialog::setNextBtn(QString text, int x, int y, int width, int hight, QString image)&#123; nextBtn = new QPushButton(this); nextBtn-&gt;setText(text); nextBtn-&gt;setGeometry(QRect(x, y, width, hight)); nextBtn-&gt;setStyleSheet(image); if(text == tr("下一步")) connect(nextBtn, &amp;QPushButton::clicked, this, &amp;Dialog::next_clicked); else if(text == tr("上一步")) connect(nextBtn, &amp;QPushButton::clicked, this, &amp;Dialog::last_clicked); else if(text == tr("bfs显示")) connect(nextBtn, &amp;QPushButton::clicked, this, &amp;Dialog::bfsOutput_clicked); else if(text == tr("dfs显示")) connect(nextBtn, &amp;QPushButton::clicked, this, &amp;Dialog::dfsOutput_clicked); else if(text == tr("显示距离")) connect(nextBtn, &amp;QPushButton::clicked, this, &amp;Dialog::floydOutput_clicked);&#125; 现在回头看，发觉用switch语句可读性与效率都应该更高些。 第三个坑（输出）有了输出组件，当然应该还需要准确的输出与标准化显示。我采取流和字符串来同时进行操作，以达到准确输出，如：//矩阵形式输出图void adjacencyWGraph::outputWithAdjacency(string &amp;s)const&#123; stringstream ss; string temp; s += " "; for (int i = 0; i &lt; n; i++) &#123; for(int k = 0; k &lt; maxLength+2-1; k++)&#123; s += " "; &#125; ss.clear(); ss &lt;&lt; vertex[i]; ss &gt;&gt; temp; s += temp; &#125; s += "\r"; for (int i = 1; i &lt;= n; i++) &#123; ss.clear(); ss &lt;&lt; vertex[i - 1]; ss &gt;&gt; temp; s += temp; for(int k = 0; k &lt; maxLength+2-1; k++)&#123; s += " "; &#125; for (int j = 1; j &lt;= n; j++) &#123; if (a[i][j] != INT_MAX) &#123; ss.clear(); ss &lt;&lt; a[i][j]; ss &gt;&gt; temp; s += temp; for(int k = 0; k &lt; maxLength+2-(int)temp.length(); k++)&#123; s += " "; &#125; &#125; else &#123; s += "∞"; for(int k = 0; k &lt; maxLength; k++)&#123; s += " "; &#125; &#125; &#125; s += "\r"; &#125; //cout&lt;&lt;s&lt;&lt;endl;&#125; 其中maxLength是我为了达到尽量的标准化输出而来获取到的输入当中的最大字符串的长度（或是权值的字符串形式的长度）。函数如下：//获取输入的字符串的最大长度，以保持输出的整齐void adjacencyWGraph::getMaxLength()&#123; stringstream ss; this-&gt;maxLength = 2; string temp; int length; for(int i=0;i&lt;n;i++)&#123; temp = vertex[i]; length = temp.length(); if(length&gt;maxLength)&#123; maxLength = length; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (a[i][j] != INT_MAX) &#123; ss.clear(); ss &lt;&lt; a[i][j]; ss &gt;&gt; temp; length = temp.length(); if(length&gt;maxLength)&#123; maxLength = length; &#125; &#125; &#125; &#125;&#125; 第四个坑（异常）我们考虑到了需要抛出异常这个功能，在这里就是当输入非法时，提示用户输入错误，并告述他正确的输入格式让他重新输入。由于时间因素，我并没有完成这个功能，而是给了一个格式说明的界面以及输入的默认提示文字来提示用户正确输入。 第五个坑（QTextBrowser）这是一个天坑，在我万般百度、谷歌的情况下依旧未被解决的问题。就是当输入图的顶点过多时（大概超过15个）时，矩阵形式输出在界面上是没法看的，过量的顶点字符会排到第二行，（当时连滑条都做出来了，还是没有滑动的按钮==），不过值得欣慰的是，复制粘贴到文本文档里面并不会换行，格式还是对的。 第六个坑（布局）只有主菜单界面是栅格布局。 第七个坑（画图）最开始是想用QT的2D绘图功能来输出的，最后，当然不了了之了== 效果图主界面 手动输入界面 全图效果 源码链接 GraphOperator]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj1797(RE)]]></title>
    <url>%2F2018%2Fhello-world%2F</url>
    <content type="text"><![CDATA[虽然这个代码RE了，但我在debug()了一下午的过程中，踩了一个又一个的坑，所以记录下来。 题目大意有 n 个城市，m 条道路，在每条道路上有一个承载量，现在要求从 1 到 n 城市最大承载量，而最大承载量就是从城市 1 到城市 n 所有通路上的最大承载量 思路 以起点建立邻接表，用一个队列来存放所有起点为1的点； 每次从队列中取出一个点,并把以取出点的终点为起点的点放入队列，继续往下找，直到遇到最终点（保存每次的最小承载量）或者没有下一个点； 取出最小值中的最大值 代码定义struct Node&#123; int to; int cost;&#125;;struct helpNode&#123; int from, to; int cost;&#125;;bool cmp(helpNode a, helpNode b)&#123; return a.from &lt; b.from;&#125;vector&lt;vector&lt;Node&gt; &gt; start;vector&lt;Node&gt; save;vector&lt;Node&gt; kong;int T, N, M; 处理函数，找到最大承载量int doit()&#123; queue&lt;Node&gt; Q; for (int i = 0; i &lt; start[1].size();i++)&#123; Q.push(start[1][i]); &#125; Node temp, next; while(!Q.empty())&#123; temp = Q.front(); Q.pop(); if(temp.to==N)&#123; save.push_back(temp); &#125; int x = temp.to; for (int i = 0; i &lt; start[x].size();i++)&#123; next = start[x][i]; if(temp.cost&lt;next.cost)&#123; next.cost = temp.cost; &#125; Q.push(next); &#125; &#125; int max = 0; for (int i = 0; i &lt; save.size();i++)&#123; if(max&lt;save[i].cost)&#123; max = save[i].cost; &#125; &#125; return max;&#125; 主函数（输入处理）int main()&#123; cin &gt;&gt; T; for (int i = 1; i &lt; T + 1;i++)&#123; cin &gt;&gt; N &gt;&gt; M; save.clear(); start.clear(); kong.clear(); helpNode temp; Node tt; vector&lt;helpNode&gt; help; int len = start.size(); for (int j = 0; j &lt; M;j++)&#123; cin &gt;&gt; temp.from &gt;&gt; temp.to &gt;&gt; temp.cost; if(temp.from&gt;temp.to)&#123; swap(temp.from, temp.to); &#125; //start[x].push_back(temp); help.push_back(temp); //存储输入的所有点 &#125; sort(help.begin(), help.end(), cmp); //从小到大排序 temp = help[help.size() - 1]; help.push_back(temp); //增加最后一个元素 使最后两个一定相同 int number = 0; for (int k = 0; k &lt; help.size()-1;k++)&#123; number = help[k].from; tt.to = help[k].to; tt.cost = help[k].cost; if(help[k+1].from==help[k].from)&#123; save.push_back(tt); //相同起点的放入一个数组中 &#125; else&#123; int n = number - start.size(); while(n!=0)&#123; start.push_back(kong); n--; &#125; save.push_back(tt); //不同时,存入help[k]; start.push_back(save); save.clear(); &#125; &#125; start.push_back(save); //存入最后一组起点相同de save.clear(); int result = doit(); cout &lt;&lt; "Scenario #" &lt;&lt; i &lt;&lt; ":" &lt;&lt; endl; cout &lt;&lt; result &lt;&lt; endl; &#125; cout &lt;&lt; endl; return 0;&#125; 总结vector对vector更熟练的运用，尤其是二维动态的，两个维度都是动态增长，且满足图的需求，即需要让一部分一维数组元素为空。 初始化 这是一个相当重要的过程，每次你需要用一个队列、数组或者邻接矩阵，都需要考虑一下是否需要初始化，怎样初始化。 尤其需要注意每次循环完毕之后，当前的值是否被存起来了。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>vector</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
</search>
