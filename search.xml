<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2Flove_files%2Fjscex.min%2F</url>
    <content type="text"><![CDATA[(function(){var b={DEBUG:1,INFO:2,WARN:3,ERROR:4},d=function(){this.level=b.WARN};d.prototype={log:function(a){try{console.log(a)}catch(b){}},debug:function(a){this.level]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2Flove_files%2Fjquery.min%2F</url>
    <content type="text"><![CDATA[/*! jQuery v1.7.1 jquery.com | jquery.org/license */ (function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cv(a){if(!ck[a]){var b=c.body,d=f("").appendTo(b),e=d.css("display");d.remove();if(e==="none"||e===""){cl||(cl=c.createElement("iframe"),cl.frameBorder=cl.width=cl.height=0),b.appendChild(cl);if(!cm||!cl.createElement)cm=(cl.contentWindow||cl.contentDocument).document,cm.write((c.compatMode==="CSS1Compat"?"":"")+""),cm.close();d=cm.createElement(a),cm.body.appendChild(d),e=f.css(d,"display"),b.removeChild(cl)}ck[a]=e}return ck[a]}function cu(a,b){var c={};f.each(cq.concat.apply([],cq.slice(0,b)),function(){c[this]=a});return c}function ct(){cr=b}function cs(){setTimeout(ct,0);return cr=f.now()}function cj(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}function ci(){try{return new a.XMLHttpRequest}catch(b){}}function cc(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g0){if(c!=="border")for(;g=0===c})}function S(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function K(){return!0}function J(){return!1}function n(a,b,c){var d=b+"defer",e=b+"queue",g=b+"mark",h=f._data(a,d);h&&(c==="queue"||!f._data(a,e))&&(c==="mark"||!f._data(a,g))&&setTimeout(function(){!f._data(a,e)&&!f._data(a,g)&&(f.removeData(a,d,!0),h.fire())},0)}function m(a){for(var b in a){if(b==="data"&&f.isEmptyObject(a[b]))continue;if(b!=="toJSON")return!1}return!0}function l(a,c,d){if(d===b&&a.nodeType===1){var e="data-"+c.replace(k,"-$1").toLowerCase();d=a.getAttribute(e);if(typeof d=="string"){try{d=d==="true"?!0:d==="false"?!1:d==="null"?null:f.isNumeric(d)?parseFloat(d):j.test(d)?f.parseJSON(d):d}catch(g){}f.data(a,c,d)}else d=b}return d}function h(a){var b=g[a]={},c,d;a=a.split(/\s+/);for(c=0,d=a.length;c)[^>]*$|#([\w\-]*)$)/,j=/\S/,k=/^\s+/,l=/\s+$/,m=/^(?:)?$/,n=/^[\],:{}\s]*$/,o=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,p=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,q=/(?:^|:|,)(?:\s*\[)+/g,r=/(webkit)[ \/]([\w.]+)/,s=/(opera)(?:.*version)?[ \/]([\w.]+)/,t=/(msie) ([\w.]+)/,u=/(mozilla)(?:.*? rv:([\w.]+))?/,v=/-([a-z]|[0-9])/ig,w=/^-ms-/,x=function(a,b){return(b+"").toUpperCase()},y=d.userAgent,z,A,B,C=Object.prototype.toString,D=Object.prototype.hasOwnProperty,E=Array.prototype.push,F=Array.prototype.slice,G=String.prototype.trim,H=Array.prototype.indexOf,I={};e.fn=e.prototype={constructor:e,init:function(a,d,f){var g,h,j,k;if(!a)return this;if(a.nodeType){this.context=this[0]=a,this.length=1;return this}if(a==="body"&&!d&&c.body){this.context=c,this[0]=c.body,this.selector=a,this.length=1;return this}if(typeof a=="string"){a.charAt(0)!==""||a.length0)return;A.fireWith(c,[e]),e.fn.trigger&&e(c).trigger("ready").off("ready")}},bindReady:function(){if(!A){A=e.Callbacks("once memory");if(c.readyState==="complete")return setTimeout(e.ready,1);if(c.addEventListener)c.addEventListener("DOMContentLoaded",B,!1),a.addEventListener("load",e.ready,!1);else if(c.attachEvent){c.attachEvent("onreadystatechange",B),a.attachEvent("onload",e.ready);var b=!1;try{b=a.frameElement==null}catch(d){}c.documentElement.doScroll&&b&&J()}}},isFunction:function(a){return e.type(a)==="function"},isArray:Array.isArray||function(a){return e.type(a)==="array"},isWindow:function(a){return a&&typeof a=="object"&&"setInterval"in a},isNumeric:function(a){return!isNaN(parseFloat(a))&&isFinite(a)},type:function(a){return a==null?String(a):I[C.call(a)]||"object"},isPlainObject:function(a){if(!a||e.type(a)!=="object"||a.nodeType||e.isWindow(a))return!1;try{if(a.constructor&&!D.call(a,"constructor")&&!D.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}var d;for(d in a);return d===b||D.call(a,d)},isEmptyObject:function(a){for(var b in a)return!1;return!0},error:function(a){throw new Error(a)},parseJSON:function(b){if(typeof b!="string"||!b)return null;b=e.trim(b);if(a.JSON&&a.JSON.parse)return a.JSON.parse(b);if(n.test(b.replace(o,"@").replace(p,"]").replace(q,"")))return(new Function("return "+b))();e.error("Invalid JSON: "+b)},parseXML:function(c){var d,f;try{a.DOMParser?(f=new DOMParser,d=f.parseFromString(c,"text/xml")):(d=new ActiveXObject("Microsoft.XMLDOM"),d.async="false",d.loadXML(c))}catch(g){d=b}(!d||!d.documentElement||d.getElementsByTagName("parsererror").length)&&e.error("Invalid XML: "+c);return d},noop:function(){},globalEval:function(b){b&&j.test(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(w,"ms-").replace(v,x)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,c,d){var f,g=0,h=a.length,i=h===b||e.isFunction(a);if(d){if(i){for(f in a)if(c.apply(a[f],d)===!1)break}else for(;g]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2Flove_files%2Ffunctions%2F</url>
    <content type="text"><![CDATA[// variables var $win = $(window); var clientWidth = $win.width(); var clientHeight = $win.height(); $(window).resize(function() { var newWidth = $win.width(); var newHeight = $win.height(); if (newWidth != clientWidth && newHeight != clientHeight) { location.replace(location); } }); (function($) { $.fn.typewriter = function() { this.each(function() { var $ele = $(this), str = $ele.html(), progress = 0; $ele.html(''); var timer = setInterval(function() { var current = str.substr(progress, 1); if (current == ']]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2Flove_files%2Fdefault%2F</url>
    <content type="text"><![CDATA[body{margin:0;padding:0;background:#ffe;font-size:14px;font-family:'微软雅黑','宋体',sans-serif;color:#231F20;overflow:auto} a {color:#000;font-size:14px;} #main{width:100%;} #wrap{position:relative;margin:0 auto;width:1100px;height:680px;margin-top:10px;} #text{width:400px;height:425px;left:60px;top:80px;position:absolute;} #code{display:none;font-size:16px;} #clock-box {position:absolute;left:60px;top:550px;font-size:28px;display:none;} #clock-box a {font-size:28px;text-decoration:none;} #clock{margin-left:48px;} #clock .digit {font-size:64px;} #canvas{margin:0 auto;width:1100px;height:680px;} #error{margin:0 auto;text-align:center;margin-top:60px;display:none;} .hand{cursor:pointer;} .say{margin-left:5px;} .space{margin-right:150px;} .big{ font-family: "微软雅黑"; color: rgb(247, 123, 8); font-size: 35px; } .c31{ color: #FB6900; font-size: 20px; } .c1{ color: #EA0015; font-size: 25px; } .c2{ color: #D5002A; font-size: 25px; } .c3{ color: #C0003F; } .c4{ color: #AB0054; } .c5{ color: #960069; } .c6{ color: #81007E; } .c7{ color: #6C0093; } .c8{ color: #5700A8; } .c9{ color: #4200BD; } .c10{ color: #2D00D2; } .c11{ color: #1800E7; } .c12{ color: #0300FC; } .c13{ color: #3042EC; } .c14{ color: #2D51D9; } .c15{ color: #2A60C6; } .c16{ color: #276FB3; } .c17{ color: #247EA0; font-size: 25px; } .c18{ color: #218D8D; } .c19{ color: #1E9C7A; } .c20{ color: #1BAB67; } .c21{ color: #18BA54; } .c22{ color: #15C941; } .c23{ color: #12D82E; } .c24{ color: #0FE71B; font-size: 25px; } .c25{ color: #0CF608; } .c26{ color: #5BE100; font-size: 25px; } .c27{ color: #83C300; } .c28{ color: #ABA500; } .c29{ color: #D38700; } .c30{ color: #FB6900; } #photos { width:80px; /*宽度*/ height:80px; /*高度*/ margin:150px auto; /* transform:rotateY(0deg); */ transform:rotateY(-10deg); transform-style:preserve-3d;/*设置3d环境*/ } #photos img{ width:100%; height:100%; position:absolute; box-shadow:0 0 8px #eaeaea; box-shadow: 1px -1px 6px #666; border-radius:4px; -webkit-box-reflect:below 3px -webkit-linear-gradient(top,rgba(0,0,0,0) 40%,rgba(0,0,0,0.5)); cursor:pointer; padding:5px; background:transparent; background-clip: padding-box; }]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2Flove_files%2Fpw%2F</url>
    <content type="text"><![CDATA[var photosDom = document.getElementById('photos'); var images = photosDom.getElementsByTagName('img'); var len = images.length; var deg = Math.floor(360 / len); for (var i = 0; i < len; i++) { images[i].style = 'transform : rotateY(' + deg * i + 'deg) translateZ(180px)'; } var x = 0; setInterval(function () { photosDom.style.transform = "rotateX(-10deg) rotateY(" + (x++) * 0.2 + "deg)"; }, 30); // photosDom.style.display = "none"; var image1 = document.getElementById('image1'); var image2 = document.getElementById('image2'); var image3 = document.getElementById('image3'); var image4 = document.getElementById('image4'); var image5 = document.getElementById('image5'); var image6 = document.getElementById('image6'); var image7 = document.getElementById('image7'); var image8 = document.getElementById('image8'); var image9 = document.getElementById('image9'); image1.style.display = "none"; image2.style.display = "none"; image3.style.display = "none"; image4.style.display = "none"; image5.style.display = "none"; image6.style.display = "none"; image7.style.display = "none"; image8.style.display = "none"; image9.style.display = "none"; function image1fans(){ image1.style.display = "block"; } function image2fans(){ image2.style.display = "block"; } function image3fans(){ image3.style.display = "block"; } function image4fans(){ image4.style.display = "block"; } function image5fans(){ image5.style.display = "block"; } function image6fans(){ image6.style.display = "block"; } function image7fans(){ image7.style.display = "block"; } function image8fans(){ image8.style.display = "block"; } function image9fans(){ image9.style.display = "block"; } function imageShow() { setTimeout("image9fans()", 1000); setTimeout("image7fans()", 3000); setTimeout("image5fans()", 5000); setTimeout("image3fans()", 7000); setTimeout("image1fans()", 9000); setTimeout("image8fans()", 11000); setTimeout("image6fans()", 13000); setTimeout("image4fans()", 15000); setTimeout("image2fans()", 17000); } document.getElementById("bgAudio").volume = 0.2;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2Flove_files%2Flove%2F</url>
    <content type="text"><![CDATA[(function(window){ function random(min, max) { return min + Math.floor(Math.random() * (max - min + 1)); } function bezier(cp, t) { var p1 = cp[0].mul((1 - t) * (1 - t)); var p2 = cp[1].mul(2 * t * (1 - t)); var p3 = cp[2].mul(t * t); return p1.add(p2).add(p3); } function inheart(x, y, r) { // x^2+(y-(x^2)^(1/3))^2 = 1 // http://www.wolframalpha.com/input/?i=x%5E2%2B%28y-%28x%5E2%29%5E%281%2F3%29%29%5E2+%3D+1 var z = ((x / r) * (x / r) + (y / r) * (y / r) - 1) * ((x / r) * (x / r) + (y / r) * (y / r) - 1) * ((x / r) * (x / r) + (y / r) * (y / r) - 1) - (x / r) * (x / r) * (y / r) * (y / r) * (y / r); return z < 0; } Point = function(x, y) { this.x = x || 0; this.y = y || 0; } Point.prototype = { clone: function() { return new Point(this.x, this.y); }, add: function(o) { p = this.clone(); p.x += o.x; p.y += o.y; return p; }, sub: function(o) { p = this.clone(); p.x -= o.x; p.y -= o.y; return p; }, div: function(n) { p = this.clone(); p.x /= n; p.y /= n; return p; }, mul: function(n) { p = this.clone(); p.x *= n; p.y *= n; return p; } } Heart = function() { // x = 16 sin^3 t // y = 13 cos t - 5 cos 2t - 2 cos 3t - cos 4t // http://www.wolframalpha.com/input/?i=x+%3D+16+sin%5E3+t%2C+y+%3D+(13+cos+t+-+5+cos+2t+-+2+cos+3t+-+cos+4t) var points = [], x, y, t; for (var i = 10; i < 30; i += 0.2) { t = i / Math.PI; x = 16 * Math.pow(Math.sin(t), 3); y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t); points.push(new Point(x, y)); } this.points = points; this.length = points.length; } Heart.prototype = { get: function(i, scale) { return this.points[i].mul(scale || 1); } } Seed = function(tree, point, scale, color) { this.tree = tree; var scale = scale || 1 var color = color || '#FF0000'; this.heart = { point : point, scale : scale, color : color, figure : new Heart(), } this.cirle = { point : point, scale : scale, color : color, radius : 5, } } Seed.prototype = { draw: function() { this.drawHeart(); this.drawText(); }, addPosition: function(x, y) { this.cirle.point = this.cirle.point.add(new Point(x, y)); }, canMove: function() { return this.cirle.point.y < (this.tree.height + 20); }, move: function(x, y) { this.clear(); this.drawCirle(); this.addPosition(x, y); }, canScale: function() { return this.heart.scale > 0.2; }, setHeartScale: function(scale) { this.heart.scale *= scale; }, scale: function(scale) { this.clear(); this.drawCirle(); this.drawHeart(); this.setHeartScale(scale); }, drawHeart: function() { var ctx = this.tree.ctx, heart = this.heart; var point = heart.point, color = heart.color, scale = heart.scale; ctx.save(); ctx.fillStyle = color; ctx.translate(point.x, point.y); ctx.beginPath(); ctx.moveTo(0, 0); for (var i = 0; i < heart.figure.length; i++) { var p = heart.figure.get(i, scale); ctx.lineTo(p.x, -p.y); } ctx.closePath(); ctx.fill(); ctx.restore(); }, drawCirle: function() { var ctx = this.tree.ctx, cirle = this.cirle; var point = cirle.point, color = cirle.color, scale = cirle.scale, radius = cirle.radius; ctx.save(); ctx.fillStyle = color; ctx.translate(point.x, point.y); ctx.scale(scale, scale); ctx.beginPath(); ctx.moveTo(0, 0); ctx.arc(0, 0, radius, 0, 2 * Math.PI); ctx.closePath(); ctx.fill(); ctx.restore(); }, drawText: function() { var ctx = this.tree.ctx, heart = this.heart; var point = heart.point, color = heart.color, scale = heart.scale; ctx.save(); ctx.strokeStyle = color; ctx.fillStyle = color; ctx.translate(point.x, point.y); ctx.scale(scale, scale); ctx.moveTo(0, 0); ctx.lineTo(15, 15); ctx.lineTo(60, 15); ctx.stroke(); ctx.moveTo(0, 0); ctx.scale(0.75, 0.75); ctx.font = "12px 微软雅黑,Verdana"; // 字号肿么没有用? (ˉ(∞)ˉ) ctx.fillText("click here", 23, 16); ctx.restore(); }, clear: function() { var ctx = this.tree.ctx, cirle = this.cirle; var point = cirle.point, scale = cirle.scale, radius = 26; var w = h = (radius * scale); ctx.clearRect(point.x - w, point.y - h, 4 * w, 4 * h); }, hover: function(x, y) { var ctx = this.tree.ctx; var pixel = ctx.getImageData(x, y, 1, 1); return pixel.data[3] == 255 } } Footer = function(tree, width, height, speed) { this.tree = tree; this.point = new Point(tree.seed.heart.point.x, tree.height - height / 2); this.width = width; this.height = height; this.speed = speed || 2; this.length = 0; } Footer.prototype = { draw: function() { var ctx = this.tree.ctx, point = this.point; var len = this.length / 2; ctx.save(); ctx.strokeStyle = 'rgb(35, 31, 32)'; ctx.lineWidth = this.height; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.translate(point.x, point.y); ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(len, 0); ctx.lineTo(-len, 0); ctx.stroke(); ctx.restore(); if (this.length < this.width) { this.length += this.speed; } } } Tree = function(canvas, width, height, opt) { this.canvas = canvas; this.ctx = canvas.getContext('2d'); this.width = width; this.height = height; this.opt = opt || {}; this.record = {}; this.initSeed(); this.initFooter(); this.initBranch(); this.initBloom(); } Tree.prototype = { initSeed: function() { var seed = this.opt.seed || {}; var x = seed.x || this.width / 2; var y = seed.y || this.height / 2; var point = new Point(x, y); var color = seed.color || '#FF0000'; var scale = seed.scale || 1; this.seed = new Seed(this, point, scale, color); }, initFooter: function() { var footer = this.opt.footer || {}; var width = footer.width || this.width; var height = footer.height || 5; var speed = footer.speed || 2; this.footer = new Footer(this, width, height, speed); }, initBranch: function() { var branchs = this.opt.branch || [] this.branchs = []; this.addBranchs(branchs); }, initBloom: function() { var bloom = this.opt.bloom || {}; var cache = [], num = bloom.num || 500, width = bloom.width || this.width, height = bloom.height || this.height, figure = this.seed.heart.figure; var r = 240, x, y; for (var i = 0; i < num; i++) { cache.push(this.createBloom(width, height, r, figure)); } this.blooms = []; this.bloomsCache = cache; }, toDataURL: function(type) { return this.canvas.toDataURL(type); }, draw: function(k) { var s = this, ctx = s.ctx; var rec = s.record[k]; if (!rec) { return ; } var point = rec.point, image = rec.image; ctx.save(); ctx.putImageData(image, point.x, point.y); ctx.restore(); }, addBranch: function(branch) { this.branchs.push(branch); }, addBranchs: function(branchs){ var s = this, b, p1, p2, p3, r, l, c; for (var i = 0; i < branchs.length; i++) { b = branchs[i]; p1 = new Point(b[0], b[1]); p2 = new Point(b[2], b[3]); p3 = new Point(b[4], b[5]); r = b[6]; l = b[7]; c = b[8] s.addBranch(new Branch(s, p1, p2, p3, r, l, c)); } }, removeBranch: function(branch) { var branchs = this.branchs; for (var i = 0; i < branchs.length; i++) { if (branchs[i] === branch) { branchs.splice(i, 1); } } }, canGrow: function() { return !!this.branchs.length; }, grow: function() { var branchs = this.branchs; for (var i = 0; i < branchs.length; i++) { var branch = branchs[i]; if (branch) { branch.grow(); } } }, addBloom: function (bloom) { this.blooms.push(bloom); }, removeBloom: function (bloom) { var blooms = this.blooms; for (var i = 0; i < blooms.length; i++) { if (blooms[i] === bloom) { blooms.splice(i, 1); } } }, createBloom: function(width, height, radius, figure, color, alpha, angle, scale, place, speed) { var x, y; while (true) { x = random(20, width - 20); y = random(20, height - 20); if (inheart(x - width / 2, height - (height - 40) / 2 - y, radius)) { return new Bloom(this, new Point(x, y), figure, color, alpha, angle, scale, place, speed); } } }, canFlower: function() { return !!this.blooms.length; }, flower: function(num) { var s = this, blooms = s.bloomsCache.splice(0, num); for (var i = 0; i < blooms.length; i++) { s.addBloom(blooms[i]); } blooms = s.blooms; for (var j = 0; j < blooms.length; j++) { blooms[j].flower(); } }, snapshot: function(k, x, y, width, height) { var ctx = this.ctx; var image = ctx.getImageData(x, y, width, height); this.record[k] = { image: image, point: new Point(x, y), width: width, height: height } }, setSpeed: function(k, speed) { this.record[k || "move"].speed = speed; }, move: function(k, x, y) { var s = this, ctx = s.ctx; var rec = s.record[k || "move"]; var point = rec.point, image = rec.image, speed = rec.speed || 10, width = rec.width, height = rec.height; i = point.x + speed < x ? point.x + speed : x; j = point.y + speed < y ? point.y + speed : y; ctx.save(); ctx.clearRect(point.x, point.y, width, height); ctx.putImageData(image, i, j); ctx.restore(); rec.point = new Point(i, j); rec.speed = speed * 0.95; if (rec.speed < 2) { rec.speed = 2; } return i < x || j < y; }, jump: function() { var s = this, blooms = s.blooms; if (blooms.length) { for (var i = 0; i < blooms.length; i++) { blooms[i].jump(); } } if ((blooms.length && blooms.length < 3) || !blooms.length) { var bloom = this.opt.bloom || {}, width = bloom.width || this.width, height = bloom.height || this.height, figure = this.seed.heart.figure; var r = 240, x, y; for (var i = 0; i < random(1,2); i++) { blooms.push(this.createBloom(width / 2 + width, height, r, figure, null, 1, null, 1, new Point(random(-100,600), 720), random(200,300))); } } } } Branch = function(tree, point1, point2, point3, radius, length, branchs) { this.tree = tree; this.point1 = point1; this.point2 = point2; this.point3 = point3; this.radius = radius; this.length = length || 100; this.len = 0; this.t = 1 / (this.length - 1); this.branchs = branchs || []; } Branch.prototype = { grow: function() { var s = this, p; if (s.len 1) { s.tree.removeBloom(s); } }, draw: function() { var s = this, ctx = s.tree.ctx, figure = s.figure; ctx.save(); ctx.fillStyle = s.color; ctx.globalAlpha = s.alpha; ctx.translate(s.point.x, s.point.y); ctx.scale(s.scale, s.scale); ctx.rotate(s.angle); ctx.beginPath(); ctx.moveTo(0, 0); for (var i = 0; i < figure.length; i++) { var p = figure.get(i); ctx.lineTo(p.x, -p.y); } ctx.closePath(); ctx.fill(); ctx.restore(); }, jump: function() { var s = this, height = s.tree.height; if (s.point.x < -20 || s.point.y > height + 20) { s.tree.removeBloom(s); } else { s.draw(); s.point = s.place.sub(s.point).div(s.speed).add(s.point); s.angle += 0.05; s.speed -= 1; } } } window.random = random; window.bezier = bezier; window.Point = Point; window.Tree = Tree; })(window);]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2Flove_files%2Fjscex-parser%2F</url>
    <content type="text"><![CDATA[/*********************************************************************** A JavaScript tokenizer / parser / beautifier / compressor. This version is suitable for Node.js. With minimal changes (the exports stuff) it should work on any JS platform. This file contains the tokenizer/parser. It is a port to JavaScript of parse-js [1], a JavaScript parser library written in Common Lisp by Marijn Haverbeke. Thank you Marijn! [1] http://marijn.haverbeke.nl/parse-js/ Exported functions: - tokenizer(code) -- returns a function. Call the returned function to fetch the next token. - parse(code) -- returns an AST of the given JavaScript code. -------------------------------- (C) --------------------------------- Author: Mihai Bazon http://mihai.bazon.net/blog Distributed under the BSD license: Copyright 2010 (c) Mihai Bazon Based on parse-js (http://marijn.haverbeke.nl/parse-js/). Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ***********************************************************************/ (function () { /* -----[ Tokenizer (constants) ]----- */ var KEYWORDS = array_to_hash([ "break", "case", "catch", "const", "continue", "default", "delete", "do", "else", "finally", "for", "function", "if", "in", "instanceof", "new", "return", "switch", "throw", "try", "typeof", "var", "void", "while", "with" ]); var RESERVED_WORDS = array_to_hash([ "abstract", "boolean", "byte", "char", "class", "debugger", "double", "enum", "export", "extends", "final", "float", "goto", "implements", "import", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "super", "synchronized", "throws", "transient", "volatile" ]); var KEYWORDS_BEFORE_EXPRESSION = array_to_hash([ "return", "new", "delete", "throw", "else", "case" ]); var KEYWORDS_ATOM = array_to_hash([ "false", "null", "true", "undefined" ]); var OPERATOR_CHARS = array_to_hash(characters("+-*&%=!?|~^")); var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i; var RE_OCT_NUMBER = /^0[0-7]+$/; var RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i; var OPERATORS = array_to_hash([ "in", "instanceof", "typeof", "new", "void", "delete", "++", "--", "+", "-", "!", "~", "&", "|", "^", "*", "/", "%", ">>", ">", "", "=", "==", "===", "!=", "!==", "?", "=", "+=", "-=", "/=", "*=", "%=", ">>=", ">=", "|=", "^=", "&=", "&&", "||" ]); var WHITESPACE_CHARS = array_to_hash(characters(" \n\r\t\u200b")); var PUNC_BEFORE_EXPRESSION = array_to_hash(characters("[{}(,.;:")); var PUNC_CHARS = array_to_hash(characters("[]{}(),;:")); var REGEXP_MODIFIERS = array_to_hash(characters("gmsiy")); /* -----[ Tokenizer ]----- */ // regexps adapted from http://xregexp.com/plugins/#unicode var UNICODE = { letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0523\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971\\u0972\\u097B-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D3D\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8B\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10D0-\\u10FA\\u10FC\\u1100-\\u1159\\u115F-\\u11A2\\u11A8-\\u11F9\\u1200-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u1676\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19A9\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u2094\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2C6F\\u2C71-\\u2C7D\\u2C80-\\u2CE4\\u2D00-\\u2D25\\u2D30-\\u2D65\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31B7\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FC3\\uA000-\\uA48C\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA65F\\uA662-\\uA66E\\uA67F-\\uA697\\uA717-\\uA71F\\uA722-\\uA788\\uA78B\\uA78C\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA90A-\\uA925\\uA930-\\uA946\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAC00\\uD7A3\\uF900-\\uFA2D\\uFA30-\\uFA6A\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"), non_spacing_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065E\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0900-\\u0902\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F90-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFD-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"), space_combining_mark: new RegExp("[\\u0903\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]"), connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]") }; function is_letter(ch) { return UNICODE.letter.test(ch); }; function is_digit(ch) { ch = ch.charCodeAt(0); return ch >= 48 && ch 0; --n) { var digit = parseInt(next(true), 16); if (isNaN(digit)) parse_error("Invalid hex-character pattern in string"); num = (num < 4) | digit; } return num; }; function read_string() { return with_eof_error("Unterminated string constant", function(){ var quote = next(), ret = ""; for (;;) { var ch = next(true); if (ch == "\\") ch = read_escaped_char(); else if (ch == quote) break; ret += ch; } return token("string", ret); }); }; function read_line_comment() { next(); var i = find("\n"), ret; if (i == -1) { ret = S.text.substr(S.pos); S.pos = S.text.length; } else { ret = S.text.substring(S.pos, i); S.pos = i; } return token("comment1", ret, true); }; function read_multiline_comment() { next(); return with_eof_error("Unterminated multiline comment", function(){ var i = find("*/", true), text = S.text.substring(S.pos, i), tok = token("comment2", text, true); S.pos = i + 2; S.line += text.split("\n").length - 1; S.newline_before = text.indexOf("\n") >= 0; // https://github.com/mishoo/UglifyJS/issues/#issue/100 if (/^@cc_on/i.test(text)) { warn("WARNING: at line " + S.line); warn("*** Found \"conditional comment\": " + text); warn("*** UglifyJS DISCARDS ALL COMMENTS. This means your code might no longer work properly in Internet Explorer."); } return tok; }); }; function read_name() { var backslash = false, name = "", ch; while ((ch = peek()) != null) { if (!backslash) { if (ch == "\\") backslash = true, next(); else if (is_identifier_char(ch)) name += next(); else break; } else { if (ch != "u") parse_error("Expecting UnicodeEscapeSequence -- uXXXX"); ch = read_escaped_char(); if (!is_identifier_char(ch)) parse_error("Unicode char: " + ch.charCodeAt(0) + " is not valid in identifier"); name += ch; backslash = false; } } return name; }; function read_regexp() { return with_eof_error("Unterminated regular expression", function(){ var prev_backslash = false, regexp = "", ch, in_class = false; while ((ch = next(true))) if (prev_backslash) { regexp += "\\" + ch; prev_backslash = false; } else if (ch == "[") { in_class = true; regexp += ch; } else if (ch == "]" && in_class) { in_class = false; regexp += ch; } else if (ch == "/" && !in_class) { break; } else if (ch == "\\") { prev_backslash = true; } else { regexp += ch; } var mods = read_name(); return token("regexp", [ regexp, mods ]); }); }; function read_operator(prefix) { function grow(op) { if (!peek()) return op; var bigger = op + peek(); if (HOP(OPERATORS, bigger)) { next(); return grow(bigger); } else { return op; } }; return token("operator", grow(prefix || next())); }; function handle_slash() { next(); var regex_allowed = S.regex_allowed; switch (peek()) { case "/": S.comments_before.push(read_line_comment()); S.regex_allowed = regex_allowed; return next_token(); case "*": S.comments_before.push(read_multiline_comment()); S.regex_allowed = regex_allowed; return next_token(); } return S.regex_allowed ? read_regexp() : read_operator("/"); }; function handle_dot() { next(); return is_digit(peek()) ? read_num(".") : token("punc", "."); }; function read_word() { var word = read_name(); return !HOP(KEYWORDS, word) ? token("name", word) : HOP(OPERATORS, word) ? token("operator", word) : HOP(KEYWORDS_ATOM, word) ? token("atom", word) : token("keyword", word); }; function with_eof_error(eof_error, cont) { try { return cont(); } catch(ex) { if (ex === EX_EOF) parse_error(eof_error); else throw ex; } }; function next_token(force_regexp) { if (force_regexp) return read_regexp(); skip_whitespace(); start_token(); var ch = peek(); if (!ch) return token("eof"); if (is_digit(ch)) return read_num(); if (ch == '"' || ch == "'") return read_string(); if (HOP(PUNC_CHARS, ch)) return token("punc", next()); if (ch == ".") return handle_dot(); if (ch == "/") return handle_slash(); if (HOP(OPERATOR_CHARS, ch)) return read_operator(); if (ch == "\\" || is_identifier_start(ch)) return read_word(); parse_error("Unexpected character '" + ch + "'"); }; next_token.context = function(nc) { if (nc) S = nc; return S; }; return next_token; }; /* -----[ Parser (constants) ]----- */ var UNARY_PREFIX = array_to_hash([ "typeof", "void", "delete", "--", "++", "!", "~", "-", "+" ]); var UNARY_POSTFIX = array_to_hash([ "--", "++" ]); var ASSIGNMENT = (function(a, ret, i){ while (i < a.length) { ret[a[i]] = a[i].substr(0, a[i].length - 1); i++; } return ret; })( ["+=", "-=", "/=", "*=", "%=", ">>=", "=", "|=", "^=", "&="], { "=": true }, 0 ); var PRECEDENCE = (function(a, ret){ for (var i = 0, n = 1; i < a.length; ++i, ++n) { var b = a[i]; for (var j = 0; j < b.length; ++j) { ret[b[j]] = n; } } return ret; })( [ ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["", "=", "in", "instanceof"], [">>", ">"], ["+", "-"], ["*", "/", "%"] ], {} ); var STATEMENTS_WITH_LABELS = array_to_hash([ "for", "do", "while", "switch" ]); var ATOMIC_START_TOKEN = array_to_hash([ "atom", "num", "string", "regexp", "name" ]); /* -----[ Parser ]----- */ function NodeWithToken(str, start, end) { this.name = str; this.start = start; this.end = end; }; NodeWithToken.prototype.toString = function() { return this.name; }; function parse($TEXT, exigent_mode, embed_tokens) { var S = { input : typeof $TEXT == "string" ? tokenizer($TEXT, true) : $TEXT, token : null, prev : null, peeked : null, in_function : 0, in_loop : 0, labels : [] }; S.token = next(); function is(type, value) { return is_token(S.token, type, value); }; function peek() { return S.peeked || (S.peeked = S.input()); }; function next() { S.prev = S.token; if (S.peeked) { S.token = S.peeked; S.peeked = null; } else { S.token = S.input(); } return S.token; }; function prev() { return S.prev; }; function croak(msg, line, col, pos) { var ctx = S.input.context(); js_error(msg, line != null ? line : ctx.tokline, col != null ? col : ctx.tokcol, pos != null ? pos : ctx.tokpos); }; function token_error(token, msg) { croak(msg, token.line, token.col); }; function unexpected(token) { if (token == null) token = S.token; token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")"); }; function expect_token(type, val) { if (is(type, val)) { return next(); } token_error(S.token, "Unexpected token " + S.token.type + ", expected " + type); }; function expect(punc) { return expect_token("punc", punc); }; function can_insert_semicolon() { return !exigent_mode && ( S.token.nlb || is("eof") || is("punc", "}") ); }; function semicolon() { if (is("punc", ";")) next(); else if (!can_insert_semicolon()) unexpected(); }; function as() { return slice(arguments); }; function parenthesised() { expect("("); var ex = expression(); expect(")"); return ex; }; function add_tokens(str, start, end) { return str instanceof NodeWithToken ? str : new NodeWithToken(str, start, end); }; var statement = embed_tokens ? function() { var start = S.token; var ast = $statement.apply(this, arguments); ast[0] = add_tokens(ast[0], start, prev()); return ast; } : $statement; function $statement() { if (is("operator", "/")) { S.peeked = null; S.token = S.input(true); // force regexp } switch (S.token.type) { case "num": case "string": case "regexp": case "operator": case "atom": return simple_statement(); case "name": return is_token(peek(), "punc", ":") ? labeled_statement(prog1(S.token.value, next, next)) : simple_statement(); case "punc": switch (S.token.value) { case "{": return as("block", block_()); case "[": case "(": return simple_statement(); case ";": next(); return as("block"); default: unexpected(); } case "keyword": switch (prog1(S.token.value, next)) { case "break": return break_cont("break"); case "continue": return break_cont("continue"); case "debugger": semicolon(); return as("debugger"); case "do": return (function(body){ expect_token("keyword", "while"); return as("do", prog1(parenthesised, semicolon), body); })(in_loop(statement)); case "for": return for_(); case "function": return function_(true); case "if": return if_(); case "return": if (S.in_function == 0) croak("'return' outside of function"); return as("return", is("punc", ";") ? (next(), null) : can_insert_semicolon() ? null : prog1(expression, semicolon)); case "switch": return as("switch", parenthesised(), switch_block_()); case "throw": return as("throw", prog1(expression, semicolon)); case "try": return try_(); case "var": return prog1(var_, semicolon); case "const": return prog1(const_, semicolon); case "while": return as("while", parenthesised(), in_loop(statement)); case "with": return as("with", parenthesised(), statement()); default: unexpected(); } } }; function labeled_statement(label) { S.labels.push(label); var start = S.token, stat = statement(); if (exigent_mode && !HOP(STATEMENTS_WITH_LABELS, stat[0])) unexpected(start); S.labels.pop(); return as("label", label, stat); }; function simple_statement() { return as("stat", prog1(expression, semicolon)); }; function break_cont(type) { var name = is("name") ? S.token.value : null; if (name != null) { next(); if (!member(name, S.labels)) croak("Label " + name + " without matching loop or statement"); } else if (S.in_loop == 0) croak(type + " not inside a loop or switch"); semicolon(); return as(type, name); }; function for_() { expect("("); var init = null; if (!is("punc", ";")) { init = is("keyword", "var") ? (next(), var_(true)) : expression(true, true); if (is("operator", "in")) return for_in(init); } return regular_for(init); }; function regular_for(init) { expect(";"); var test = is("punc", ";") ? null : expression(); expect(";"); var step = is("punc", ")") ? null : expression(); expect(")"); return as("for", init, test, step, in_loop(statement)); }; function for_in(init) { var lhs = init[0] == "var" ? as("name", init[1][0]) : init; next(); var obj = expression(); expect(")"); return as("for-in", init, lhs, obj, in_loop(statement)); }; var function_ = embed_tokens ? function() { var start = prev(); var ast = $function_.apply(this, arguments); ast[0] = add_tokens(ast[0], start, prev()); return ast; } : $function_; function $function_(in_statement) { var name = is("name") ? prog1(S.token.value, next) : null; if (in_statement && !name) unexpected(); expect("("); return as(in_statement ? "defun" : "function", name, // arguments (function(first, a){ while (!is("punc", ")")) { if (first) first = false; else expect(","); if (!is("name")) unexpected(); a.push(S.token.value); next(); } next(); return a; })(true, []), // body (function(){ ++S.in_function; var loop = S.in_loop; S.in_loop = 0; var a = block_(); --S.in_function; S.in_loop = loop; return a; })()); }; function if_() { var cond = parenthesised(), body = statement(), belse; if (is("keyword", "else")) { next(); belse = statement(); } return as("if", cond, body, belse); }; function block_() { expect("{"); var a = []; while (!is("punc", "}")) { if (is("eof")) unexpected(); a.push(statement()); } next(); return a; }; var switch_block_ = curry(in_loop, function(){ expect("{"); var a = [], cur = null; while (!is("punc", "}")) { if (is("eof")) unexpected(); if (is("keyword", "case")) { next(); cur = []; a.push([ expression(), cur ]); expect(":"); } else if (is("keyword", "default")) { next(); expect(":"); cur = []; a.push([ null, cur ]); } else { if (!cur) unexpected(); cur.push(statement()); } } next(); return a; }); function try_() { var body = block_(), bcatch, bfinally; if (is("keyword", "catch")) { next(); expect("("); if (!is("name")) croak("Name expected"); var name = S.token.value; next(); expect(")"); bcatch = [ name, block_() ]; } if (is("keyword", "finally")) { next(); bfinally = block_(); } if (!bcatch && !bfinally) croak("Missing catch/finally blocks"); return as("try", body, bcatch, bfinally); }; function vardefs(no_in) { var a = []; for (;;) { if (!is("name")) unexpected(); var name = S.token.value; next(); if (is("operator", "=")) { next(); a.push([ name, expression(false, no_in) ]); } else { a.push([ name ]); } if (!is("punc", ",")) break; next(); } return a; }; function var_(no_in) { return as("var", vardefs(no_in)); }; function const_() { return as("const", vardefs()); }; function new_() { var newexp = expr_atom(false), args; if (is("punc", "(")) { next(); args = expr_list(")"); } else { args = []; } return subscripts(as("new", newexp, args), true); }; function expr_atom(allow_calls) { if (is("operator", "new")) { next(); return new_(); } if (is("operator") && HOP(UNARY_PREFIX, S.token.value)) { return make_unary("unary-prefix", prog1(S.token.value, next), expr_atom(allow_calls)); } if (is("punc")) { switch (S.token.value) { case "(": next(); return subscripts(prog1(expression, curry(expect, ")")), allow_calls); case "[": next(); return subscripts(array_(), allow_calls); case "{": next(); return subscripts(object_(), allow_calls); } unexpected(); } if (is("keyword", "function")) { next(); return subscripts(function_(false), allow_calls); } if (HOP(ATOMIC_START_TOKEN, S.token.type)) { var atom = S.token.type == "regexp" ? as("regexp", S.token.value[0], S.token.value[1]) : as(S.token.type, S.token.value); return subscripts(prog1(atom, next), allow_calls); } unexpected(); }; function expr_list(closing, allow_trailing_comma, allow_empty) { var first = true, a = []; while (!is("punc", closing)) { if (first) first = false; else expect(","); if (allow_trailing_comma && is("punc", closing)) break; if (is("punc", ",") && allow_empty) { a.push([ "atom", "undefined" ]); } else { a.push(expression(false)); } } next(); return a; }; function array_() { return as("array", expr_list("]", !exigent_mode, true)); }; function object_() { var first = true, a = []; while (!is("punc", "}")) { if (first) first = false; else expect(","); if (!exigent_mode && is("punc", "}")) // allow trailing comma break; var type = S.token.type; var name = as_property_name(); if (type == "name" && (name == "get" || name == "set") && !is("punc", ":")) { a.push([ as_name(), function_(false), name ]); } else { expect(":"); a.push([ name, expression(false) ]); } } next(); return as("object", a); }; function as_property_name() { switch (S.token.type) { case "num": case "string": return prog1(S.token.value, next); } return as_name(); }; function as_name() { switch (S.token.type) { case "name": case "operator": case "keyword": case "atom": return prog1(S.token.value, next); default: unexpected(); } }; function subscripts(expr, allow_calls) { if (is("punc", ".")) { next(); return subscripts(as("dot", expr, as_name()), allow_calls); } if (is("punc", "[")) { next(); return subscripts(as("sub", expr, prog1(expression, curry(expect, "]"))), allow_calls); } if (allow_calls && is("punc", "(")) { next(); return subscripts(as("call", expr, expr_list(")")), true); } if (allow_calls && is("operator") && HOP(UNARY_POSTFIX, S.token.value)) { return prog1(curry(make_unary, "unary-postfix", S.token.value, expr), next); } return expr; }; function make_unary(tag, op, expr) { if ((op == "++" || op == "--") && !is_assignable(expr)) croak("Invalid use of " + op + " operator"); return as(tag, op, expr); }; function expr_op(left, min_prec, no_in) { var op = is("operator") ? S.token.value : null; if (op && op == "in" && no_in) op = null; var prec = op != null ? PRECEDENCE[op] : null; if (prec != null && prec > min_prec) { next(); var right = expr_op(expr_atom(true), prec, no_in); return expr_op(as("binary", op, left, right), min_prec, no_in); } return left; }; function expr_ops(no_in) { return expr_op(expr_atom(true), 0, no_in); }; function maybe_conditional(no_in) { var expr = expr_ops(no_in); if (is("operator", "?")) { next(); var yes = expression(false); expect(":"); return as("conditional", expr, yes, expression(false, no_in)); } return expr; }; function is_assignable(expr) { if (!exigent_mode) return true; switch (expr[0]) { case "dot": case "sub": case "new": case "call": return true; case "name": return expr[1] != "this"; } }; function maybe_assign(no_in) { var left = maybe_conditional(no_in), val = S.token.value; if (is("operator") && HOP(ASSIGNMENT, val)) { if (is_assignable(left)) { next(); return as("assign", ASSIGNMENT[val], left, maybe_assign(no_in)); } croak("Invalid assignment"); } return left; }; function expression(commas, no_in) { if (arguments.length == 0) commas = true; var expr = maybe_assign(no_in); if (commas && is("punc", ",")) { next(); return as("seq", expr, expression(true, no_in)); } return expr; }; function in_loop(cont) { try { ++S.in_loop; return cont(); } finally { --S.in_loop; } }; return as("toplevel", (function(a){ while (!is("eof")) a.push(statement()); return a; })([])); }; /* -----[ Utilities ]----- */ function curry(f) { var args = slice(arguments, 1); return function() { return f.apply(this, args.concat(slice(arguments))); }; }; function prog1(ret) { if (ret instanceof Function) ret = ret(); for (var i = 1, n = arguments.length; --n > 0; ++i) arguments[i](); return ret; }; function array_to_hash(a) { var ret = {}; for (var i = 0; i < a.length; ++i) ret[a[i]] = true; return ret; }; function slice(a, start) { return Array.prototype.slice.call(a, start == null ? 0 : start); }; function characters(str) { return str.split(""); }; function member(name, array) { for (var i = array.length; --i >= 0;) if (array[i] === name) return true; return false; }; function HOP(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }; var warn = function() {}; /* -----[ Exports ]----- */ var init = function (root) { if (root.modules["parser"]) { return; } root.parse = parse; root.modules["parser"] = true; } var isCommonJS = (typeof require !== "undefined" && typeof module !== "undefined" && module.exports); var isAmd = (typeof define !== "undefined" && define.amd); if (isCommonJS) { module.exports.init = init; } else if (isAmd) { define("jscex-parser", function () { return { init: init }; }); } else { if (typeof Jscex === "undefined") { throw new Error('Missing root object, please load "jscex" module first.'); } init(Jscex); } /* scope.tokenizer = tokenizer; scope.parse = parse; scope.slice = slice; scope.curry = curry; scope.member = member; scope.array_to_hash = array_to_hash; scope.PRECEDENCE = PRECEDENCE; scope.KEYWORDS_ATOM = KEYWORDS_ATOM; scope.RESERVED_WORDS = RESERVED_WORDS; scope.KEYWORDS = KEYWORDS; scope.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN; scope.OPERATORS = OPERATORS; scope.is_alphanumeric_char = is_alphanumeric_char; scope.set_logger = function (logger) { warn = logger; }; */ })();]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2Flove_files%2Fjscex-jit%2F</url>
    <content type="text"><![CDATA[(function () { var codeGenerator = (typeof eval("(function () {})") == "function") ? function (code) { return code; } : function (code) { return "false || " + code; }; // support string type only. var stringify = (typeof JSON !== "undefined" && JSON.stringify) ? function (s) { return JSON.stringify(s); } : (function () { // Implementation comes from JSON2 (http://www.json.org/js.html) var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g; var meta = { // table of character substitutions '\b': '\\b', '\t': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', '"' : '\\"', '\\': '\\\\' } return function (s) { // If the string contains no control characters, no quote characters, and no // backslash characters, then we can safely slap some quotes around it. // Otherwise we must also replace the offending characters with safe escape // sequences. escapable.lastIndex = 0; return escapable.test(s) ? '"' + s.replace(escapable, function (a) { var c = meta[a]; return typeof c === 's' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4); }) + '"' : '"' + s + '"'; }; })(); // seed defined in global if (typeof __jscex__tempVarSeed === "undefined") { __jscex__tempVarSeed = 0; } var init = function (root) { if (root.modules["jit"]) { return; } function JscexTreeGenerator(binder) { this._binder = binder; this._root = null; } JscexTreeGenerator.prototype = { generate: function (ast) { var params = ast[2], statements = ast[3]; this._root = { type: "delay", stmts: [] }; this._visitStatements(statements, this._root.stmts); return this._root; }, _getBindInfo: function (stmt) { var type = stmt[0]; if (type == "stat") { var expr = stmt[1]; if (expr[0] == "call") { var callee = expr[1]; if (callee[0] == "name" && callee[1] == this._binder && expr[2].length == 1) { return { expression: expr[2][0], argName: "", assignee: null }; } } else if (expr[0] == "assign") { var assignee = expr[2]; expr = expr[3]; if (expr[0] == "call") { var callee = expr[1]; if (callee[0] == "name" && callee[1] == this._binder && expr[2].length == 1) { return { expression: expr[2][0], argName: "$$_result_$$", assignee: assignee }; } } } } else if (type == "var") { var defs = stmt[1]; if (defs.length == 1) { var item = defs[0]; var name = item[0]; var expr = item[1]; if (expr && expr[0] == "call") { var callee = expr[1]; if (callee[0] == "name" && callee[1] == this._binder && expr[2].length == 1) { return { expression: expr[2][0], argName: name, assignee: null }; } } } } else if (type == "return") { var expr = stmt[1]; if (expr && expr[0] == "call") { var callee = expr[1]; if (callee[0] == "name" && callee[1] == this._binder && expr[2].length == 1) { return { expression: expr[2][0], argName: "$$_result_$$", assignee: "return" }; } } } return null; }, _visitStatements: function (statements, stmts, index) { if (arguments.length = statements.length) { stmts.push({ type: "normal" }); return this; } var currStmt = statements[index]; var bindInfo = this._getBindInfo(currStmt); if (bindInfo) { var bindStmt = { type: "bind", info: bindInfo }; stmts.push(bindStmt); if (bindInfo.assignee != "return") { bindStmt.stmts = []; this._visitStatements(statements, bindStmt.stmts, index + 1); } } else { var type = currStmt[0]; if (type == "return" || type == "break" || type == "continue" || type == "throw") { stmts.push({ type: type, stmt: currStmt }); } else if (type == "if" || type == "try" || type == "for" || type == "do" || type == "while" || type == "switch" || type == "for-in") { var newStmt = this._visit(currStmt); if (newStmt.type == "raw") { stmts.push(newStmt); this._visitStatements(statements, stmts, index + 1); } else { var isLast = (index == statements.length - 1); if (isLast) { stmts.push(newStmt); } else { var combineStmt = { type: "combine", first: { type: "delay", stmts: [newStmt] }, second: { type: "delay", stmts: [] } }; stmts.push(combineStmt); this._visitStatements(statements, combineStmt.second.stmts, index + 1); } } } else { stmts.push({ type: "raw", stmt: currStmt }); this._visitStatements(statements, stmts, index + 1); } } return this; }, _visit: function (ast) { var type = ast[0]; function throwUnsupportedError() { throw new Error('"' + type + '" is not currently supported.'); } var visitor = this._visitors[type]; if (visitor) { return visitor.call(this, ast); } else { throwUnsupportedError(); } }, _visitBody: function (ast, stmts) { if (ast[0] == "block") { this._visitStatements(ast[1], stmts); } else { this._visitStatements([ast], stmts); } }, _noBinding: function (stmts) { switch (stmts[stmts.length - 1].type) { case "normal": case "return": case "break": case "throw": case "continue": return true; } return false; }, _collectCaseStatements: function (cases, index) { var res = []; for (var i = index; i < cases.length; i++) { var rawStmts = cases[i][1]; for (var j = 0; j < rawStmts.length; j++) { if (rawStmts[j][0] == "break") { return res } res.push(rawStmts[j]); } } return res; }, _visitors: { "for": function (ast) { var bodyStmts = []; var body = ast[4]; this._visitBody(body, bodyStmts); if (this._noBinding(bodyStmts)) { return { type: "raw", stmt: ast }; } var delayStmt = { type: "delay", stmts: [] }; var setup = ast[1]; if (setup) { delayStmt.stmts.push({ type: "raw", stmt: setup }); } var loopStmt = { type: "loop", bodyFirst: false, bodyStmt: { type: "delay", stmts: bodyStmts } }; delayStmt.stmts.push(loopStmt); var condition = ast[2]; if (condition) { loopStmt.condition = condition; } var update = ast[3]; if (update) { loopStmt.update = update; } return delayStmt; }, "for-in": function (ast) { var body = ast[4]; var bodyStmts = []; this._visitBody(body, bodyStmts); if (this._noBinding(bodyStmts)) { return { type: "raw", stmt: ast }; } var id = (__jscex__tempVarSeed++); var keysVar = "$$_keys_$$_" + id; var indexVar = "$$_index_$$_" + id; // var memVar = "$$_mem_$$_" + id; var delayStmt = { type: "delay", stmts: [] }; // var members = Jscex._forInKeys(obj); var keysAst = root.parse("var " + keysVar + " = Jscex._forInKeys(obj);")[1][0]; keysAst[1][0][1][2][0] = ast[3]; // replace obj with real AST; delayStmt.stmts.push({ type: "raw", stmt: keysAst }); /* // var members = []; delayStmt.stmts.push({ type: "raw", stmt: uglifyJS.parse("var " + membersVar + " = [];")[1][0] }); // for (var mem in obj) members.push(mem); var keysAst = uglifyJS.parse("for (var " + memVar +" in obj) " + membersVar + ".push(" + memVar + ");")[1][0]; keysAst[3] = ast[3]; // replace the "obj" with real AST. delayStmt.stmts.push({ type : "raw", stmt: keysAst}); */ // var index = 0; delayStmt.stmts.push({ type: "raw", stmt: root.parse("var " + indexVar + " = 0;")[1][0] }); // index < members.length var condition = root.parse(indexVar + " < " + keysVar + ".length")[1][0][1]; // index++ var update = root.parse(indexVar + "++")[1][0][1]; var loopStmt = { type: "loop", bodyFirst: false, update: update, condition: condition, bodyStmt: { type: "delay", stmts: [] } }; delayStmt.stmts.push(loopStmt); var varName = ast[2][1]; // ast[2] == ["name", m] if (ast[1][0] == "var") { loopStmt.bodyStmt.stmts.push({ type: "raw", stmt: root.parse("var " + varName + " = " + keysVar + "[" + indexVar + "];")[1][0] }); } else { loopStmt.bodyStmt.stmts.push({ type: "raw", stmt: root.parse(varName + " = " + keysVar + "[" + indexVar + "];")[1][0] }); } this._visitBody(body, loopStmt.bodyStmt.stmts); return delayStmt; }, "while": function (ast) { var bodyStmts = []; var body = ast[2]; this._visitBody(body, bodyStmts); if (this._noBinding(bodyStmts)) { return { type: "raw", stmt: ast } } var loopStmt = { type: "loop", bodyFirst: false, bodyStmt: { type: "delay", stmts: bodyStmts } }; var condition = ast[1]; loopStmt.condition = condition; return loopStmt; }, "do": function (ast) { var bodyStmts = []; var body = ast[2]; this._visitBody(body, bodyStmts); if (this._noBinding(bodyStmts)) { return { type: "raw", stmt: ast }; } var loopStmt = { type: "loop", bodyFirst: true, bodyStmt: { type: "delay", stmts: bodyStmts } }; var condition = ast[1]; loopStmt.condition = condition; return loopStmt; }, "switch": function (ast) { var noBinding = true; var switchStmt = { type: "switch", item: ast[1], caseStmts: [] }; var cases = ast[2]; for (var i = 0; i < cases.length; i++) { var caseStmt = { item: cases[i][0], stmts: [] }; switchStmt.caseStmts.push(caseStmt); var statements = this._collectCaseStatements(cases, i); this._visitStatements(statements, caseStmt.stmts); noBinding = noBinding && this._noBinding(caseStmt.stmts); } if (noBinding) { return { type: "raw", stmt: ast }; } else { return switchStmt; } }, "if": function (ast) { var noBinding = true; var ifStmt = { type: "if", conditionStmts: [] }; var currAst = ast; while (true) { var condition = currAst[1]; var condStmt = { cond: condition, stmts: [] }; ifStmt.conditionStmts.push(condStmt); var thenPart = currAst[2]; this._visitBody(thenPart, condStmt.stmts); noBinding = noBinding && this._noBinding(condStmt.stmts); var elsePart = currAst[3]; if (elsePart && elsePart[0] == "if") { currAst = elsePart; } else { break; } } var elsePart = currAst[3]; if (elsePart) { ifStmt.elseStmts = []; this._visitBody(elsePart, ifStmt.elseStmts); noBinding = noBinding && this._noBinding(ifStmt.elseStmts); } if (noBinding) { return { type: "raw", stmt: ast }; } else { return ifStmt; } }, "try": function (ast, stmts) { var bodyStmts = []; var bodyStatements = ast[1]; this._visitStatements(bodyStatements, bodyStmts); var noBinding = this._noBinding(bodyStmts) var tryStmt = { type: "try", bodyStmt: { type: "delay", stmts: bodyStmts } }; var catchClause = ast[2]; if (catchClause) { var exVar = catchClause[0]; tryStmt.exVar = exVar; tryStmt.catchStmts = []; this._visitStatements(catchClause[1], tryStmt.catchStmts); noBinding = noBinding && this._noBinding(tryStmt.catchStmts); } var finallyStatements = ast[3]; if (finallyStatements) { tryStmt.finallyStmt = { type: "delay", stmts: [] }; this._visitStatements(finallyStatements, tryStmt.finallyStmt.stmts); noBinding = noBinding && this._noBinding(tryStmt.finallyStmt.stmts); } if (noBinding) { return { type: "raw", stmt: ast }; } else { return tryStmt; } } } } function CodeGenerator(builderName, binder, indent) { this._builderName = builderName; this._binder = binder; this._normalMode = false; this._indent = indent; this._indentLevel = 0; this._builderVar = "$$_builder_$$_" + (__jscex__tempVarSeed++); } CodeGenerator.prototype = { _write: function (s) { this._buffer.push(s); return this; }, _writeLine: function (s) { this._write(s)._write("\n"); return this; }, _writeIndents: function () { for (var i = 0; i < this._indent; i++) { this._write(" "); } for (var i = 0; i < this._indentLevel; i++) { this._write(" "); } return this; }, generate: function (params, jscexAst) { this._buffer = []; this._writeLine("(function (" + params.join(", ") + ") {"); this._indentLevel++; this._writeIndents() ._writeLine("var " + this._builderVar + " = Jscex.builders[" + stringify(this._builderName) + "];"); this._writeIndents() ._writeLine("return " + this._builderVar + ".Start(this,"); this._indentLevel++; this._pos = { }; this._writeIndents() ._visitJscex(jscexAst) ._writeLine(); this._indentLevel--; this._writeIndents() ._writeLine(");"); this._indentLevel--; this._writeIndents() ._write("})"); return this._buffer.join(""); }, _visitJscex: function (ast) { this._jscexVisitors[ast.type].call(this, ast); return this; }, _visitRaw: function (ast) { var type = ast[0]; function throwUnsupportedError() { throw new Error('"' + type + '" is not currently supported.'); } var visitor = this._rawVisitors[type]; if (visitor) { visitor.call(this, ast); } else { throwUnsupportedError(); } return this; }, _visitJscexStatements: function (statements) { for (var i = 0; i < statements.length; i++) { var stmt = statements[i]; if (stmt.type == "raw" || stmt.type == "if" || stmt.type == "switch") { this._writeIndents() ._visitJscex(stmt)._writeLine(); } else if (stmt.type == "delay") { this._visitJscexStatements(stmt.stmts); } else { this._writeIndents() ._write("return ")._visitJscex(stmt)._writeLine(";"); } } }, _visitRawStatements: function (statements) { for (var i = 0; i < statements.length; i++) { var s = statements[i]; this._writeIndents() ._visitRaw(s)._writeLine(); switch (s[0]) { case "break": case "return": case "continue": case "throw": return; } } }, _visitRawBody: function (body) { if (body[0] == "block") { this._visitRaw(body); } else { this._writeLine(); this._indentLevel++; this._writeIndents() ._visitRaw(body); this._indentLevel--; } return this; }, _visitRawFunction: function (ast) { var funcName = ast[1] || ""; var args = ast[2]; var statements = ast[3]; this._writeLine("function " + funcName + "(" + args.join(", ") + ") {") this._indentLevel++; var currInFunction = this._pos.inFunction; this._pos.inFunction = true; this._visitRawStatements(statements); this._indentLevel--; this._pos.inFunction = currInFunction; this._writeIndents() ._write("}"); }, _jscexVisitors: { "delay": function (ast) { if (ast.stmts.length == 1) { var subStmt = ast.stmts[0]; switch (subStmt.type) { case "delay": case "combine": case "normal": case "break": case "continue": case "loop": case "try": this._visitJscex(subStmt); return; case "return": if (!subStmt.stmt[1]) { this._visitJscex(subStmt); return; } } } this._writeLine(this._builderVar + ".Delay(function () {"); this._indentLevel++; this._visitJscexStatements(ast.stmts); this._indentLevel--; this._writeIndents() ._write("})"); }, "combine": function (ast) { this._writeLine(this._builderVar + ".Combine("); this._indentLevel++; this._writeIndents() ._visitJscex(ast.first)._writeLine(","); this._writeIndents() ._visitJscex(ast.second)._writeLine(); this._indentLevel--; this._writeIndents() ._write(")"); }, "loop": function (ast) { this._writeLine(this._builderVar + ".Loop("); this._indentLevel++; if (ast.condition) { this._writeIndents() ._writeLine("function () {"); this._indentLevel++; this._writeIndents() ._write("return ")._visitRaw(ast.condition)._writeLine(";"); this._indentLevel--; this._writeIndents() ._writeLine("},"); } else { this._writeIndents()._writeLine("null,"); } if (ast.update) { this._writeIndents() ._writeLine("function () {"); this._indentLevel++; this._writeIndents() ._visitRaw(ast.update)._writeLine(";"); this._indentLevel--; this._writeIndents() ._writeLine("},"); } else { this._writeIndents()._writeLine("null,"); } this._writeIndents() ._visitJscex(ast.bodyStmt)._writeLine(","); this._writeIndents() ._writeLine(ast.bodyFirst); this._indentLevel--; this._writeIndents() ._write(")"); }, "raw": function (ast) { this._visitRaw(ast.stmt); }, "bind": function (ast) { var info = ast.info; this._write(this._builderVar + ".Bind(")._visitRaw(info.expression)._writeLine(", function (" + info.argName + ") {"); this._indentLevel++; if (info.assignee == "return") { this._writeIndents() ._writeLine("return " + this._builderVar + ".Return(" + info.argName + ");"); } else { if (info.assignee) { this._writeIndents() ._visitRaw(info.assignee)._writeLine(" = " + info.argName + ";"); } this._visitJscexStatements(ast.stmts); } this._indentLevel--; this._writeIndents() ._write("})"); }, "if": function (ast) { for (var i = 0; i < ast.conditionStmts.length; i++) { var stmt = ast.conditionStmts[i]; this._write("if (")._visitRaw(stmt.cond)._writeLine(") {"); this._indentLevel++; this._visitJscexStatements(stmt.stmts); this._indentLevel--; this._writeIndents() ._write("} else "); } this._writeLine("{"); this._indentLevel++; if (ast.elseStmts) { this._visitJscexStatements(ast.elseStmts); } else { this._writeIndents() ._writeLine("return " + this._builderVar + ".Normal();"); } this._indentLevel--; this._writeIndents() ._write("}"); }, "switch": function (ast) { this._write("switch (")._visitRaw(ast.item)._writeLine(") {"); this._indentLevel++; for (var i = 0; i < ast.caseStmts.length; i++) { var caseStmt = ast.caseStmts[i]; if (caseStmt.item) { this._writeIndents() ._write("case ")._visitRaw(caseStmt.item)._writeLine(":"); } else { this._writeIndents()._writeLine("default:"); } this._indentLevel++; this._visitJscexStatements(caseStmt.stmts); this._indentLevel--; } this._writeIndents() ._write("}"); }, "try": function (ast) { this._writeLine(this._builderVar + ".Try("); this._indentLevel++; this._writeIndents() ._visitJscex(ast.bodyStmt)._writeLine(","); if (ast.catchStmts) { this._writeIndents() ._writeLine("function (" + ast.exVar + ") {"); this._indentLevel++; this._visitJscexStatements(ast.catchStmts); this._indentLevel--; this._writeIndents() ._writeLine("},"); } else { this._writeIndents() ._writeLine("null,"); } if (ast.finallyStmt) { this._writeIndents() ._visitJscex(ast.finallyStmt)._writeLine(); } else { this._writeIndents() ._writeLine("null"); } this._indentLevel--; this._writeIndents() ._write(")"); }, "normal": function (ast) { this._write(this._builderVar + ".Normal()"); }, "throw": function (ast) { this._write(this._builderVar + ".Throw(")._visitRaw(ast.stmt[1])._write(")"); }, "break": function (ast) { this._write(this._builderVar + ".Break()"); }, "continue": function (ast) { this._write(this._builderVar + ".Continue()"); }, "return": function (ast) { this._write(this._builderVar + ".Return("); if (ast.stmt[1]) this._visitRaw(ast.stmt[1]); this._write(")"); } }, _rawVisitors: { "var": function (ast) { this._write("var "); var items = ast[1]; for (var i = 0; i < items.length; i++) { this._write(items[i][0]); if (items[i].length > 1) { this._write(" = ")._visitRaw(items[i][1]); } if (i < items.length - 1) this._write(", "); } this._write(";"); }, "seq": function (ast) { for (var i = 1; i < ast.length; i++) { this._visitRaw(ast[i]); if (i < ast.length - 1) this._write(", "); } }, "binary": function (ast) { var op = ast[1], left = ast[2], right = ast[3]; function needBracket(item) { var type = item[0]; return !(type == "num" || type == "name" || type == "dot"); } if (needBracket(left)) { this._write("(")._visitRaw(left)._write(") "); } else { this._visitRaw(left)._write(" "); } this._write(op); if (needBracket(right)) { this._write(" (")._visitRaw(right)._write(")"); } else { this._write(" ")._visitRaw(right); } }, "sub": function (ast) { var prop = ast[1], index = ast[2]; function needBracket() { return !(prop[0] == "name") } if (needBracket()) { this._write("(")._visitRaw(prop)._write(")[")._visitRaw(index)._write("]"); } else { this._visitRaw(prop)._write("[")._visitRaw(index)._write("]"); } }, "unary-postfix": function (ast) { var op = ast[1]; var item = ast[2]; this._visitRaw(item)._write(op); }, "unary-prefix": function (ast) { var op = ast[1]; var item = ast[2]; this._write(op); if (op == "typeof") { this._write("(")._visitRaw(item)._write(")"); } else { this._visitRaw(item); } }, "assign": function (ast) { var op = ast[1]; var name = ast[2]; var value = ast[3]; this._visitRaw(name); if ((typeof op) == "string") { this._write(" " + op + "= "); } else { this._write(" = "); } this._visitRaw(value); }, "stat": function (ast) { this._visitRaw(ast[1])._write(";"); }, "dot": function (ast) { function needBracket() { var leftOp = ast[1][0]; return !(leftOp == "dot" || leftOp == "name"); } if (needBracket()) { this._write("(")._visitRaw(ast[1])._write(").")._write(ast[2]); } else { this._visitRaw(ast[1])._write(".")._write(ast[2]); } }, "new": function (ast) { var ctor = ast[1]; this._write("new ")._visitRaw(ctor)._write("("); var args = ast[2]; for (var i = 0, len = args.length; i < len; i++) { this._visitRaw(args[i]); if (i < len - 1) this._write(", "); } this._write(")"); }, "call": function (ast) { if (_isJscexPattern(ast)) { var indent = this._indent + this._indentLevel * 4; var newCode = _compileJscexPattern(ast, indent); this._write(newCode); } else { var invalidBind = (ast[1][0] == "name") && (ast[1][1] == this._binder); if (invalidBind) { this._pos = { inFunction: true }; this._buffer = []; } this._visitRaw(ast[1])._write("("); var args = ast[2]; for (var i = 0; i < args.length; i++) { this._visitRaw(args[i]); if (i < args.length - 1) this._write(", "); } this._write(")"); if (invalidBind) { throw ("Invalid bind operation: " + this._buffer.join("")); } } }, "name": function (ast) { this._write(ast[1]); }, "object": function (ast) { var items = ast[1]; if (items.length]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2Flove_files%2Fjscex-builderbase.min%2F</url>
    <content type="text"><![CDATA[(function(){var j=function(){};j.prototype={Loop:function(b,c,a,d){return{next:function(e,i){var f=function(b){a.next(e,function(a,e){if(a=="normal"||a=="continue")g(b);else if(a=="throw"||a=="return")i(a,e);else if(a=="break")i("normal");else throw Error('Invalid type for "Loop": '+a);})},g=function(a){try{c&&!a&&c.call(e),!b||b.call(e)?f(!1):i("normal")}catch(d){i("throw",d)}};d?f(!0):g(!0)}}},Delay:function(b){return{next:function(c,a){try{b.call(c).next(c,a)}catch(d){a("throw",d)}}}},Combine:function(b, c){return{next:function(a,d){b.next(a,function(b,i,f){if(b=="normal")try{c.next(a,d)}catch(g){d("throw",g)}else d(b,i,f)})}}},Return:function(b){return{next:function(c,a){a("return",b)}}},Normal:function(){return{next:function(b,c){c("normal")}}},Break:function(){return{next:function(b,c){c("break")}}},Continue:function(){return{next:function(b,c){c("continue")}}},Throw:function(b){return{next:function(c,a){a("throw",b)}}},Try:function(b,c,a){return{next:function(d,e){b.next(d,function(b,f,g){if(b!= "throw"||!c)a?a.next(d,function(a,c,d){a=="normal"?e(b,f,g):e(a,c,d)}):e(b,f,g);else if(c){var h;try{h=c.call(d,f)}catch(j){a?a.next(d,function(a,b,c){a=="normal"?e("throw",j):e(a,b,c)}):e("throw",j)}h&&h.next(d,function(b,c,f){b=="throw"?a?a.next(d,function(a,d,g){a=="normal"?e(b,c,f):e(a,d,g)}):e(b,c,f):a?a.next(d,function(a,d,g){a=="normal"?e(b,c,f):e(a,d,g)}):e(b,c,f)})}else a.next(d,function(a,c,d){a=="normal"?e(b,f,g):e(a,c,d)})})}}}};var h=function(b){if(!b.modules)b.modules={};if(!b.modules.builderbase)b.modules.builderbase= !0,b.BuilderBase=j},k=typeof define==="function"&&!define.amd,l=typeof require==="function"&&typeof define==="function"&&define.amd;if(typeof require==="function"&&typeof module!=="undefined"&&module.exports)module.exports.init=h;else if(k)define("jscex-builderbase",function(b,c,a){a.exports.init=h});else if(l)define("jscex-builderbase",function(){return{init:h}});else{if(typeof Jscex==="undefined")throw Error('Missing the root object, please load "jscex" module first.');h(Jscex)}})();]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2Flove_files%2Fjscex-async-powerpack.min%2F</url>
    <content type="text"><![CDATA[(function(){var m=function(j){if(j.length]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2Flove_files%2Fjscex-async.min%2F</url>
    <content type="text"><![CDATA[(function(){var k=function(){};k.prototype={isCancellation:!0,message:"The task has been cancelled."};typeof __jscex__async__taskIdSeed==="undefined"&&(__jscex__async__taskIdSeed=0);var l=function(b){return typeof b.start==="function"&&typeof b.addEventListener==="function"&&typeof b.removeEventListener==="function"&&typeof b.complete==="function"},j=function(b){if(!b.modules.async){var d=function(){};d.prototype={register:function(a){this.isCancellationRequested&&a();if(!this._handlers)this._handlers= [];this._handlers.push(a)},unregister:function(a){this._handlers&&(a=this._handlers.indexOf(a),a>=0&&this._handlers.splice(a,1))},cancel:function(){if(!this.isCancellationRequested){this.isCancellationRequested=!0;var a=this._handlers;delete this._handlers;for(var f=0;f]]></content>
  </entry>
  <entry>
    <title><![CDATA[love]]></title>
    <url>%2F2018%2Flove%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>love</category>
      </categories>
      <tags>
        <tag>love</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署pyspider到云服务器上]]></title>
    <url>%2F2018%2Fpysider-deploy%2F</url>
    <content type="text"><![CDATA[因为自己一直想实现一些方便自己的小功能，所以购买了腾讯云服务器来实现爬虫脚本的自动化，而不用隔段时间自己去看小说更新没。 1.获取源1wget https://www.python.org/ftp/python/3.6.0/Python-3.6.0a1.tar.xz 如果报错Python-3.6.0a1.tar.xz: Permission denied Cannot write to ‘Python-3.6.3.tgz’ (Success).开启root权限1sudo -i 2.解压缩1tar xvf Python-3.6.0a1.tar.x 3.进入目录1．/configure 4.编译并安装12makemake install 5.安装pysider以及它的依赖包1234567sudo apt-get install python-devsudo apt-get install python-distributesudo apt-get install libcurl4-openssl-devsudo apt-get install libxml2-devsudo apt-get install libxslt1-devsudo apt-get install pythonlxmlpip install pyspider 6.配置部署12mkdir /etc/pyspider #创建文件夹vim /etc/pyspider/pyspider.conf.json 在json文件中保存下面的代码,其中mysqlUser为mysql用户名，mysqlPasswd为mysql密码，webuiUser为登录控制台的用户名，webuiPasswd为登陆控制台的密码1234567891011&#123; "taskdb": "mysql+taskdb://mysqlUser:mysqlPasswd@127.0.0.1:3306/taskdb", "projectdb": "mysql+projectdb://mysqlUser:mysqlPasswd@127.0.0.1:3306/projectdb", "resultdb": "mysql+resultdb://mysqlUser:mysqlPasswd@127.0.0.1:3306/resultdb", "message_queue": "redis://127.0.0.1:6379/db", "webui": &#123; "username": "webuiuser", "password": "webuipasswd", "need-auth": true &#125;&#125; 7.后台运行1nohup pyspider -c /etc/pyspider/pyspider.conf.json &amp; 参考 ubuntu 安装 pyspider CentOS搭建PySpider爬虫服务 CentOS部署pyspider]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pyspider</tag>
        <tag>环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo添加照片墙功能]]></title>
    <url>%2F2018%2Fhexo-add-photoWall%2F</url>
    <content type="text"><![CDATA[日新月异，距上一篇都有5个月了，因为发生了一件很开心的大事；下面还是来讲讲我的网站优化吧。 照片墙因为hexo是将文件渲染成网站的，所以最开始想的是直接写成html文件，让它不渲染即可，后来决定还是放在md文件里，填坑就开始了。。我最搜索了一下之后以为直接是正常操作，写好css之后再引入就好了，结果是自己年轻了。观察hexo其他文件之后，下面是我的about页面文件目录。 引入css文件其中的styl文件就是css样式表，1&lt;style type="text/css"&gt;@import url(pw.css);&lt;/style&gt; #注意括号里没有引号# 引入js文件正常引入就好1&lt;script src="pw.js"&gt;&lt;/script&gt; 其他插入其中的html代码要紧密，不然会再渲染之后生成&lt;br&gt;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[少年无知多欢欣]]></title>
    <url>%2F2018%2F%E5%B0%91%E5%B9%B4%E6%97%A0%E7%9F%A5%E5%A4%9A%E6%AC%A2%E6%AC%A3%2F</url>
    <content type="text"><![CDATA[你只是挥一挥手,像扔掉一张废纸，说是人生必经的事。——SHE 谁处于劣势谁仍在相思谁还在幻想 可以有一个故事谁依旧坚持谁守着无知谁还不清楚 究竟什么才是自私啊啊啊啊那时的你还年少脑子还没有开窍一和她说话 心就自然跑调以为喜欢就能一起到老却不知给她带去了多少困扰还好还好大家生活的基调仍然是欢笑那个谁谁谁还是少年只是两手空空 腰无佩剑少了好多些腼腆却那么沉默寡言]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路]]></title>
    <url>%2F2018%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[最短路的问题的各种算法都是以BFS的思想为基础，最开始的普通的入口-出口迷宫游戏也可以看作是一种最短路问题，只是在这个问题里面，每次行动的步长一样，都是1；而最短路问题里面常处理的是步长（路径长度）不一样的问题。 常用算法最短路问题有四个常用的算法，Bellman_ford、Dijkstra、floyd和spfa；其中,dijkstran算法又可以用堆优化。 Bellman-Ford 算法介绍 找出起点S到其他所有可达点的最短距离 可用来判断是否有起点S可达的负圈 在大循环内遍历边，只要该边的起点的最短距离已知晓（目前已知的最短，有可能被更新，即只要不是inf就行），那么该边的终点的最短距离则是当前点的最短距离或者是该边的起点的最短距离加上边的权值。即 d[e.to] = min(d[e.to], d[e.from] + e.cost) . 代码1234567891011121314151617181920212223242526struct edge&#123; int from,to; int cost;&#125;;edge es[maxe];int d[maxv]; //最短距离int V,E;void bellman_ford(int s)&#123; for(int i=0;i&lt;V;i++)&#123; d[i]=inf; &#125; d[s]=0; while(true)&#123; bool update = false; for(int i=0;i&lt;E;i++)&#123; edge e = es[i]; if(d[e.from] != inf &amp;&amp; d[e.to]&gt;d[e.from]+e.cost)&#123; d[e.from] = d[e.to] + e.cost; upate = true; &#125; &#125; if(!upate) break; &#125;&#125; Dijkstra 算法介绍 找出起点S到其他所有可达点的最短距离 图中存在负边，该算法就无法正确求解问题 Dijkstra算法是针对bellman_ford算法进行操作上的优化得到的。 找到最短距离已经确定的顶点，从它出发更新相邻顶点的最短距离。 此后不需要再关心 1 中的“最短距离已经确定的顶点 ”。 代码12345678910111213141516171819202122int cost[maxv][maxv];int d[maxv];bool used[maxv];int V;void dijkstra(int s)&#123; memset(d,inf,sizeof(d)); memset(used,false,sizeof(used)); d[s] = 0; while(true)&#123; int v = -1; for(int u=0;u&lt;V;u++)&#123; if(!used[u] &amp;&amp; (v==-1 || d[u] &lt; d[v])) v = u; &#125; if(v==-1) break; used[v] = true; for(int i=0;i&lt;V;i++)&#123; d[i] = min(d[i], d[v] + cost[v][i]); &#125; &#125;&#125; 堆优化每次把确定了最短距离的点同它的最短距离一起放进优先级队列里面。 1234567891011121314151617181920212223242526272829303132333435363738struct edge &#123; int to; int cost;&#125;;typedef pair&lt;int, int&gt;p; //first是最短距离,second是顶点的编号vector&lt;edge&gt; G[max_v];int d[max_v];int V; //顶点数struct cmp &#123; bool operator()(p a,p b) &#123; if (a.first &lt; b.first) return a &lt; b; return a &gt; b; &#125;&#125;;void dijkstra(int s) &#123; priority_queue&lt;p, vector&lt;p&gt;,cmp&gt; que; fill(d, d + V,INF); d[s] = 0; que.push(p(0, s)); //初始化 while (!que.empty()) &#123; p P = que.top(); que.pop(); int v = P.second; if (d[v] &lt; P.first) continue; for (int u = 0; u &lt; G[v].size(); u++) &#123; edge e = G[v][u]; if (d[e.to] &gt; d[v] + e.cost) &#123; d[e.to] = d[v] + e.cost; que.push(p(d[e.cost], d[e.to]));//wrong &#125; &#125; &#125;&#125; floyd 算法介绍 可以处理是负边的情况 寻找任意两点间的最短距离 判断图中是否有负圈，只需检查是否存在d[i][i]是负数的顶点i就可以了 代码123456789void floyd()&#123; for(int k=0;k&lt;V;k++)&#123; for(int i=0;i&lt;V;i++)&#123; for(int j=0;j&lt;V;j++)&#123; d[i][j] = min(d[i][j], d[i][k] + d[k][j]); &#125; &#125; &#125;&#125; spfa 算法介绍 可以处理负边权 有顶点入队了要记得标记vis数组，有顶点出队了记得消除那个标记 如果某个点进入队列的次数超过N次则存在负环（SPFA无法处理带负环的图） SPFA的两种写法，bfs和dfs，bfs判别负环不稳定，dfs的话判断负环很快 代码12345678910111213141516171819202122232425262728293031323334353637int spfa_bfs(int s) &#123; queue &lt;int&gt; q; memset(d,0x3f,sizeof(d)); d[s]=0; memset(c,0,sizeof(c)); memset(vis,0,sizeof(vis)); q.push(s); vis[s]=1; c[s]=1; //顶点入队vis要做标记，另外要统计顶点的入队次数 int OK=1; while(!q.empty()) &#123; int x; x=q.front(); q.pop(); vis[x]=0; //队头元素出队，并且消除标记 for(int k=f[x]; k!=0; k=nnext[k]) //遍历顶点x的邻接表 &#123; int y=v[k]; if( d[x]+w[k] &lt; d[y]) &#123; d[y]=d[x]+w[k]; //松弛 if(!vis[y]) //顶点y不在队内 &#123; vis[y]=1; //标记 c[y]++; //统计次数 q.push(y); //入队 if(c[y]&gt;NN) //超过入队次数上限，说明有负环 return OK=0; &#125; &#125; &#125; &#125; return OK; &#125; 123456789101112131415161718192021int spfa_dfs(int u) &#123; vis[u]=1; for(int k=f[u]; k!=0; k=e[k].next) &#123; int v=e[k].v,w=e[k].w; if( d[u]+w &lt; d[v] ) &#123; d[v]=d[u]+w; if(!vis[v]) &#123; if(spfa_dfs(v)) return 1; &#125; else return 1; &#125; &#125; vis[u]=0; return 0; &#125; 例题 poj1062 枚举+dijkstra. poj1860 正圈 poj3259 负圈 poj3660 传递闭包]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>小结</tag>
        <tag>spp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2018%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[关于并查集，真的是头发都焦的没得了，先说说我对并查集的理解，并查集说白了就是类似于学生时代的小团体，只要关系性质是一样的，就是一个团体，是一个集合。往往许多题上有很明显的关系条件的时候，就可以让并查集出马了。整个并查集的运用就是在对关系的充分理解以及运用的基础上,且并查集往往和其他一起考察。 poj2912题意有ｎ个人分成３组玩石头剪刀布，同一组的人出的都是一样的；只有一个人是裁判，随意出；找出哪个是才判，并且判断在进行到哪一局时可以判断出裁判。 分析 0~N-1 维护 &lt; N~2N-1 维护 = 2N~3N-1 维护 &gt; 且为了避免输入的时候有 11这种情况，维护之后就会发生错误，所以对符号两边的数字大小要进行处理。维护之后，枚举裁判，由裁判的游戏都跳过，如果剩下的没发生矛盾，这就是一个裁判，另外关于他在什么时候判定这个人是裁判的，我是看的别人的方法：看看我们枚举其他人时，比如我们假设第一个人是裁判时，第二局出错了，那说明第二句就断定了第一个人不是裁判；以此来算，我们找到裁判后，其他所有的出错局数最大的就是我们判断的步数；因为到了这一步，可以断定其他人都不是裁判了； 源码（WA）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; par;vector&lt;int&gt; rank;#define maxv 510bool judge[maxv];int pos[maxv];int N, M;struct Node&#123; int a, b; char op;&#125;;Node step[2100];void init(int n)&#123; par.clear(); rank.clear(); par.reserve(n); rank.reserve(n); for (int i = 0; i &lt; n;i++)&#123; par.push_back(i); rank.push_back(0); &#125;&#125;int find(int a)&#123; if(par.at(a)==a) return a; return par.at(a) = find(par.at(a));&#125;void unite(int a, int b)&#123; a = find(a); b = find(b); if(a==b) return; if(rank.at(a)&lt;rank.at(b)) par.at(a) = b; else&#123; par.at(b) = a; if(rank.at(a)==rank.at(b)) rank.at(a)++; &#125;&#125;bool same(int a, int b)&#123; return find(a)==find(b);&#125;int main()&#123; while(cin&gt;&gt;N&gt;&gt;M)&#123; init(N * 3); //0~N-1 小于， N~2N-1 等于, 2N~3N-1 大于 for (int i = 0; i &lt; N;i++)&#123; judge[i] = true; pos[i] = -1; &#125; for (int i = 0; i &lt; M;i++)&#123; cin &gt;&gt; step[i].a &gt;&gt; step[i].op &gt;&gt; step[i].b; switch(step[i].op)&#123; case '=': break; case '&lt;': if(step[i].a&gt;step[i].b)&#123; swap(step[i].a, step[i].b); step[i].op = '&gt;'; &#125; break; case '&gt;': if(step[i].a&gt;step[i].b)&#123; swap(step[i].a, step[i].b); step[i].op = '&lt;'; &#125; break; &#125; &#125; int count = 0; bool flag = false; for (int j = 0; j &lt; N;j++)&#123; init(N * 3); for (int i = 0; i &lt; M;i++)&#123; flag = false; if(step[i].a==j||step[i].b==j) continue; switch(step[i].op)&#123; case '&lt;': if(same(step[i].a+N,step[i].b+N)||same(step[i].a+2*N,step[i].b+2*N))&#123; judge[j] = false; pos[j] = i + 1; flag = true; break; &#125; unite(step[i].a, step[i].b); break; case '=': if(same(step[i].a,step[i].b)||same(step[i].a+2*N,step[i].b+2*N))&#123; judge[j] = false; pos[j] = i + 1; flag = true; break; &#125; unite(step[i].a+N,step[i].b+N); break; case '&gt;': if(same(step[i].a+N,step[i].b+N)||same(step[i].a,step[i].b))&#123; judge[j] = false; pos[j] = i + 1; flag = true; break; &#125; unite(step[i].a+2*N,step[i].b+2*N); break; &#125; if(flag==true) break; &#125; &#125; int res = 0; int maxRes = 0; for(int k=0;k&lt;N;k++)&#123; if(judge[k]==true)&#123; count++; res = k; &#125; else&#123; if(maxRes&lt;pos[k]) maxRes = pos[k]; &#125; &#125; if(count==0) cout &lt;&lt; "Impossible" &lt;&lt; endl; else if(count&gt;1)&#123; cout &lt;&lt; "Can not determine" &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; "Player " &lt;&lt; res &lt;&lt; " can be determined to be the judge after " &lt;&lt; maxRes &lt;&lt;" lines" &lt;&lt; endl; &#125; &#125; return 0;&#125; 关于做题最怕遇到的就是这种情况，所有的能找到的数据都过了，但是提交上去就WA了，一天了，还是没改对，所以先放在这里，以后再遇到类似的题或者再做这个专题的时候，再回过来看看。 后续（3.18）经好友良某的提醒，终于找出了逻辑上的错误，果然还是分析的时候不够细致啊。在上述代码中，如果输入1&lt;2、2&lt;3，那么就会并到一起时就会默认1&lt;3了，这看起来没什么不对，但这是个划拳游戏啊，是不可能得到1&lt;3的。 poj1308题意判断是否是一棵树，如图中只有3不是。 分析这题可以用树的性质来做，但因为我是做的专题，就从并查集的角度来分析： 如果一个节点有两个父节点，不是树，相当于关系矛盾了。 如果有环（自环），不是树 如果全部节点不在一个集合里，不是树 源码(MLE)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; par;int maxCin = 0;void init()&#123; maxCin = 0; par.clear(); par.reserve(0);&#125;int find(int a)&#123; if(par.at(a)==a) return a; return par.at(a) = find(par.at(a));&#125;void unite(int a, int b)&#123; int temp = a &gt; b ? a : b; if(temp&gt;maxCin)&#123; maxCin = temp; for (int i = par.size(); i &lt; maxCin + 1;i++)&#123; par.push_back(i); &#125; &#125; par.at(b) = a;&#125;bool helpsame(int a, int b)&#123; int temp = a &gt; b ? a : b; if(temp&gt;maxCin)&#123; maxCin = temp; for (int i = par.size(); i &lt; maxCin + 1;i++)&#123; par.push_back(i); &#125; &#125; if(par.at(b)!=b)//该节点已经有父节点 return true; else return false;&#125;bool same(int a, int b)&#123;//用来查是否只存在一个连通分量 return find(a) == find(b);&#125;int main()&#123; int a, b; init(); int count = 0; bool flag = false; while(cin&gt;&gt;a&gt;&gt;b)&#123; if(a==-1&amp;&amp;b==-1) break; else if(a==0&amp;&amp;b==0)&#123; // for (int k = 0; k &lt; par.size();k++)&#123; // int x = find(k); // cout &lt;&lt; x &lt;&lt; " "; // &#125; count++; if(flag==true) cout &lt;&lt; "Case " &lt;&lt; count &lt;&lt; " is not a tree." &lt;&lt; endl; else&#123; for (int i = 0; i &lt; par.size();i++)&#123; if(par.at(i)==i) continue; for (int j = 0; j &lt; par.size();j++)&#123; if(par.at(j)==j) continue; if(!same(i,j)) flag = true; break; &#125; if(flag==true) break; &#125; if(flag==true) cout &lt;&lt; "Case " &lt;&lt; count &lt;&lt; " is not a tree." &lt;&lt; endl; else cout &lt;&lt; "Case " &lt;&lt; count &lt;&lt; " is a tree." &lt;&lt; endl; &#125; init(); flag = false; &#125; else&#123; if(helpsame(a,b))&#123; flag = true; //cout &lt;&lt; "a" &lt;&lt; a &lt;&lt; "--" &lt;&lt; b &lt;&lt; endl; &#125; else if(a==b)&#123; flag = true; //cout &lt;&lt; a &lt;&lt; "--" &lt;&lt; b &lt;&lt; "b" &lt;&lt; endl; &#125; else&#123; unite(a, b); &#125; &#125; &#125; return 0;&#125; 关于这道题我读完题之后，第一反应就是没给输入的范围，自然而然的就用vector来实现。而且我的代码是那么的节约内存了都，怎么都不明白怎么会MLE的。网上的代码我复制过来提交了的，居然AC了，那份代码还是默认的输入的数据大小不会超过100！ poj1417emmmm题意：好人说的真话，坏人说的谎话。这道题题读了半天才读懂，后来发现读懂了还是不会做，而且绕口,比如：如果一个人说他自己是好人，他究竟是好人还是坏人。emmmmm,留着，以后再来。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Union-Find</tag>
        <tag>小结</tag>
        <tag>later</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以前的画]]></title>
    <url>%2F2018%2F%E4%BB%A5%E5%89%8D%E7%9A%84%E7%94%BB%2F</url>
    <content type="text"><![CDATA[灵感会变身成诗，还会变身成画；人也会变身，会变得胆小和复杂；呼呼哧哧间，人就不在那个地方了，但诗还在，画也在。 原创————数星星的人下面的这两幅图是我在绵阳的自习课上画的（铅笔），两幅画完成时间相差很久，代表了当时不同的心境，现在的我也无法回忆起当初甚至是几乎持有零星记忆。 渊这幅画可以从不同的角度，不同的顺序去看，中间有很明显的分割线，但每部分又有部分与其他部分相接。 惑月这幅画完全记不起了，大概记得就是当初听到 荧惑守心 这个成语之后有感而发，就瞎画了这幅画吧。 临摹————仿佛若有光下面的三幅图基本都是在大一的课上完成的，相差时间很近，因为是临摹（中性笔），也就很少其他因素了。 christmas当时在课上，不知道在哪里看到的这张图，觉得甚是喜欢，就不禁画了下来。 提莫这是在高数课上画的，背后还是草稿~~~ 女警这个这个，忘了忘了。。。 时间想我以前多喜欢画画啊，桌子上，书上，尽管许许多多都是我自己定义的抽象画，emmm,这门手艺可不能丢了！]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>绘画</tag>
        <tag>原创</tag>
        <tag>临摹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单搜索]]></title>
    <url>%2F2018%2F%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[前段时间都在做Kuangbin的专题一 简单搜索 ，好多都是边百度边看边想才写出来的，（学习嘛，都是从模仿开始的 == ）还有些是看了自己也没写出来，现在重做一遍部分题，并对这个专题做个小结。 DFS简述 DFS 全名 depth first search , 其主要思想就是：a.从当前点出发，不断进行递归，找到可以用的新的点 b.如果新的点终点或是边界，就回溯一次，（即让上一个点成为下次递归的点） 不断重复a、b两个步骤，直到最后无法回溯或者其他原因是跳出循环。 主要用于 查找图中通路的条数，或者是放置某样东西的方法的种数。 注意 对标记数组的处理，回溯之后对标记数组要进行还原。 123used[j] = true;dfs(index + 1, num-1);used[j] = false; 递归的参数多样性。 1dfs(index + 1, num-1); 递归结束的时间点。 12345678910if(n-index&lt;num)&#123; return;&#125;if(index&gt;n+1&amp;&amp;num!=0)&#123; return;&#125;if(num==0)&#123; res++; return;&#125; 以上例子：poj1321。 BFS简述 BFS 全名 breadth first search , 其主要思想就是：a.从当前点出发，把所有的可到达的下一个点存放进队列中，除非找到终点跳出循环。 b.取出队列的一个点，然后重复a步骤。 最开始把起点放进队列中，执行b步骤。 主要用于 寻找最短路径或者是到达终点的最小步数。 注意 多起点。（例：hdu2612 、uva11624） hdu2612：多次初始化并多次bfs. 1234init(R,C);doit(ax, ay);init(R, C);doit(bx, by); uva11624：一次将所有起点放进队列中，一次bfs 1234567if(str[i][j]=='F') &#123; F.xx=i; F.yy=j; F.t=0; F.isf=true; que.push(F);///将所有火坐标加入队列 &#125; 路径存储。（例：poj3984） 12345678910111213141516171819202122232425262728293031struct Node&#123; int x, y; int preX, preY;&#125;;for (int i = 0; i &lt; 4;i++)&#123; next.preX = temp.x; next.preY = temp.y; next.x = temp.x + dx[i]; next.y = temp.y + dy[i]; if(check(next.x,next.y))&#123; vis[next.x][next.y] = false; Q.push(next); &#125;&#125;//倒序存储while(i--&amp;&amp;i&gt;-1)&#123; i = j; //cout &lt;&lt; "i" &lt;&lt; i &lt;&lt; endl; temp = V.at(i); roate.push_back(temp); for (j = i - 1; j &gt; -1;j--)&#123; next = V.at(j); if(temp.preX == next.x &amp;&amp; temp.preY == next.y)&#123; //cout &lt;&lt; "j" &lt;&lt; j&lt;&lt;endl; break; &#125; &#125;&#125; bfs双入口。(例：poj1426 + 二进制压缩)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>小结</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The basic operator of the graph]]></title>
    <url>%2F2018%2FThe-basic-operator-of-the-graph%2F</url>
    <content type="text"><![CDATA[这是我们计算机问题求解课程的一个课程设计，我们在期末复习的大环境下赶完了这份工，虽算不上一份满意的答卷，但毕竟完成度还是比较高。下面我就关于我所做的部分做一下还原与总结。 题目理解图论的基本概念，图的矩阵表示，图的连通性，图的遍历，以及求图的连通支方法。实现如下功能：分工建议： 以结点对的形式输入一个无向简单图的边，建立该图的邻接矩阵，判断图是否连通。（1人） 并计算任意两个结点间的距离。（1 人） 对不连通的图输出其各个连通支。（1 人） 系统搭建（1 人） 过程与分析我负责系统搭建(其实就是图形界面的建立)，考虑到QT与c++的关系，自然选择以QT来进行图形界面的开发。 第一个坑（初学）学习一样新的东西时，尽量选择相关说明文档或者相关书籍，而不是选择相关视频进行学习，因为视频实在太慢了。QT可以直接进行ui的设计，拖动按钮、输入组件、显示组件等这些组件，但根据我的分析来看，至少有七八个界面，所以不得不用代码来操作。（如果直接全部ui来了要我有何用==） 第二个坑（组件设计）关于这些组件的设置，要尽量定义少的组件，使整个代码才不那么乱。当时采取简单的if-else来达到目的，如：1234567891011121314151617void Dialog::setNextBtn(QString text, int x, int y, int width, int hight, QString image)&#123; nextBtn = new QPushButton(this); nextBtn-&gt;setText(text); nextBtn-&gt;setGeometry(QRect(x, y, width, hight)); nextBtn-&gt;setStyleSheet(image); if(text == tr("下一步")) connect(nextBtn, &amp;QPushButton::clicked, this, &amp;Dialog::next_clicked); else if(text == tr("上一步")) connect(nextBtn, &amp;QPushButton::clicked, this, &amp;Dialog::last_clicked); else if(text == tr("bfs显示")) connect(nextBtn, &amp;QPushButton::clicked, this, &amp;Dialog::bfsOutput_clicked); else if(text == tr("dfs显示")) connect(nextBtn, &amp;QPushButton::clicked, this, &amp;Dialog::dfsOutput_clicked); else if(text == tr("显示距离")) connect(nextBtn, &amp;QPushButton::clicked, this, &amp;Dialog::floydOutput_clicked);&#125; 现在回头看，发觉用switch语句可读性与效率都应该更高些。 第三个坑（输出）有了输出组件，当然应该还需要准确的输出与标准化显示。我采取流和字符串来同时进行操作，以达到准确输出，如：12345678910111213141516171819202122232425262728293031323334353637383940414243444546//矩阵形式输出图void adjacencyWGraph::outputWithAdjacency(string &amp;s)const&#123; stringstream ss; string temp; s += " "; for (int i = 0; i &lt; n; i++) &#123; for(int k = 0; k &lt; maxLength+2-1; k++)&#123; s += " "; &#125; ss.clear(); ss &lt;&lt; vertex[i]; ss &gt;&gt; temp; s += temp; &#125; s += "\r"; for (int i = 1; i &lt;= n; i++) &#123; ss.clear(); ss &lt;&lt; vertex[i - 1]; ss &gt;&gt; temp; s += temp; for(int k = 0; k &lt; maxLength+2-1; k++)&#123; s += " "; &#125; for (int j = 1; j &lt;= n; j++) &#123; if (a[i][j] != INT_MAX) &#123; ss.clear(); ss &lt;&lt; a[i][j]; ss &gt;&gt; temp; s += temp; for(int k = 0; k &lt; maxLength+2-(int)temp.length(); k++)&#123; s += " "; &#125; &#125; else &#123; s += "∞"; for(int k = 0; k &lt; maxLength; k++)&#123; s += " "; &#125; &#125; &#125; s += "\r"; &#125; //cout&lt;&lt;s&lt;&lt;endl;&#125; 其中maxLength是我为了达到尽量的标准化输出而来获取到的输入当中的最大字符串的长度（或是权值的字符串形式的长度）。函数如下：12345678910111213141516171819202122232425262728//获取输入的字符串的最大长度，以保持输出的整齐void adjacencyWGraph::getMaxLength()&#123; stringstream ss; this-&gt;maxLength = 2; string temp; int length; for(int i=0;i&lt;n;i++)&#123; temp = vertex[i]; length = temp.length(); if(length&gt;maxLength)&#123; maxLength = length; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (a[i][j] != INT_MAX) &#123; ss.clear(); ss &lt;&lt; a[i][j]; ss &gt;&gt; temp; length = temp.length(); if(length&gt;maxLength)&#123; maxLength = length; &#125; &#125; &#125; &#125;&#125; 第四个坑（异常）我们考虑到了需要抛出异常这个功能，在这里就是当输入非法时，提示用户输入错误，并告述他正确的输入格式让他重新输入。由于时间因素，我并没有完成这个功能，而是给了一个格式说明的界面以及输入的默认提示文字来提示用户正确输入。 第五个坑（QTextBrowser）这是一个天坑，在我万般百度、谷歌的情况下依旧未被解决的问题。就是当输入图的顶点过多时（大概超过15个）时，矩阵形式输出在界面上是没法看的，过量的顶点字符会排到第二行，（当时连滑条都做出来了，还是没有滑动的按钮==），不过值得欣慰的是，复制粘贴到文本文档里面并不会换行，格式还是对的。 第六个坑（布局）只有主菜单界面是栅格布局。 第七个坑（画图）最开始是想用QT的2D绘图功能来输出的，最后，当然不了了之了== 效果图主界面 手动输入界面 全图效果 源码链接 GraphOperator]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj1797(RE)]]></title>
    <url>%2F2018%2Fhello-world%2F</url>
    <content type="text"><![CDATA[虽然这个代码RE了，但我在debug()了一下午的过程中，踩了一个又一个的坑，所以记录下来。 题目大意有 n 个城市，m 条道路，在每条道路上有一个承载量，现在要求从 1 到 n 城市最大承载量，而最大承载量就是从城市 1 到城市 n 所有通路上的最大承载量 思路 以起点建立邻接表，用一个队列来存放所有起点为1的点； 每次从队列中取出一个点,并把以取出点的终点为起点的点放入队列，继续往下找，直到遇到最终点（保存每次的最小承载量）或者没有下一个点； 取出最小值中的最大值 代码定义123456789101112131415struct Node&#123; int to; int cost;&#125;;struct helpNode&#123; int from, to; int cost;&#125;;bool cmp(helpNode a, helpNode b)&#123; return a.from &lt; b.from;&#125;vector&lt;vector&lt;Node&gt; &gt; start;vector&lt;Node&gt; save;vector&lt;Node&gt; kong;int T, N, M; 处理函数，找到最大承载量1234567891011121314151617181920212223242526272829int doit()&#123; queue&lt;Node&gt; Q; for (int i = 0; i &lt; start[1].size();i++)&#123; Q.push(start[1][i]); &#125; Node temp, next; while(!Q.empty())&#123; temp = Q.front(); Q.pop(); if(temp.to==N)&#123; save.push_back(temp); &#125; int x = temp.to; for (int i = 0; i &lt; start[x].size();i++)&#123; next = start[x][i]; if(temp.cost&lt;next.cost)&#123; next.cost = temp.cost; &#125; Q.push(next); &#125; &#125; int max = 0; for (int i = 0; i &lt; save.size();i++)&#123; if(max&lt;save[i].cost)&#123; max = save[i].cost; &#125; &#125; return max;&#125; 主函数（输入处理）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int main()&#123; cin &gt;&gt; T; for (int i = 1; i &lt; T + 1;i++)&#123; cin &gt;&gt; N &gt;&gt; M; save.clear(); start.clear(); kong.clear(); helpNode temp; Node tt; vector&lt;helpNode&gt; help; int len = start.size(); for (int j = 0; j &lt; M;j++)&#123; cin &gt;&gt; temp.from &gt;&gt; temp.to &gt;&gt; temp.cost; if(temp.from&gt;temp.to)&#123; swap(temp.from, temp.to); &#125; //start[x].push_back(temp); help.push_back(temp); //存储输入的所有点 &#125; sort(help.begin(), help.end(), cmp); //从小到大排序 temp = help[help.size() - 1]; help.push_back(temp); //增加最后一个元素 使最后两个一定相同 int number = 0; for (int k = 0; k &lt; help.size()-1;k++)&#123; number = help[k].from; tt.to = help[k].to; tt.cost = help[k].cost; if(help[k+1].from==help[k].from)&#123; save.push_back(tt); //相同起点的放入一个数组中 &#125; else&#123; int n = number - start.size(); while(n!=0)&#123; start.push_back(kong); n--; &#125; save.push_back(tt); //不同时,存入help[k]; start.push_back(save); save.clear(); &#125; &#125; start.push_back(save); //存入最后一组起点相同de save.clear(); int result = doit(); cout &lt;&lt; "Scenario #" &lt;&lt; i &lt;&lt; ":" &lt;&lt; endl; cout &lt;&lt; result &lt;&lt; endl; &#125; cout &lt;&lt; endl; return 0;&#125; 总结vector对vector更熟练的运用，尤其是二维动态的，两个维度都是动态增长，且满足图的需求，即需要让一部分一维数组元素为空。 初始化 这是一个相当重要的过程，每次你需要用一个队列、数组或者邻接矩阵，都需要考虑一下是否需要初始化，怎样初始化。 尤其需要注意每次循环完毕之后，当前的值是否被存起来了。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>vector</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
</search>
